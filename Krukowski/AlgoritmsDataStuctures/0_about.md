# Структуры данных

Этот документ содержит основные и специализированные структуры данных, которые широко используются в программировании. Каждая структура данных включает краткое описание, основные методы с их скоростью в Big O и области применения.

## 1. Простые структуры данных

### Массивы (Arrays)

**Описание:** Набор элементов, хранящихся в непрерывной области памяти, доступ к которым осуществляется по индексу.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Доступ по индексу     | Получение элемента по индексу       | O(1)              | Быстрый доступ к элементам     |
| Поиск                 | Линейный поиск элемента             | O(n)              | Поиск элемента в массиве       |
| Вставка               | Вставка элемента в конец массива    | O(1)              | Добавление в конец             |
| Вставка               | Вставка элемента в середину массива | O(n)              | Перемещение элементов          |
| Удаление              | Удаление элемента                   | O(n)              | Перемещение элементов          |

**Использование:** Подходят для задач, где нужен быстрый доступ к элементам по индексу и где размер данных известен заранее.

### Связные списки (Linked Lists)

**Описание:** Последовательность элементов, где каждый элемент содержит ссылку на следующий (и/или предыдущий) элемент.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Вставка в начало      | Вставка элемента в начало списка    | O(1)              | Быстрое добавление элементов   |
| Вставка в конец       | Вставка элемента в конец списка     | O(1) или O(n)     | Добавление элемента в конец    |
| Удаление              | Удаление первого элемента           | O(1)              | Быстрое удаление элементов     |
| Поиск                 | Поиск элемента                      | O(n)              | Поиск элемента в списке        |
| Доступ по индексу     | Получение элемента по индексу       | O(n)              | Медленный доступ по индексу    |

**Использование:** Эффективны, когда требуется часто вставлять и удалять элементы в начале или конце списка, но медлительны для доступа по индексу.

## 2. Абстрактные типы данных (ADT)

### Стеки (Stacks)

**Описание:** LIFO (Last In, First Out) структура данных, где последний добавленный элемент извлекается первым.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Push                  | Добавление элемента в стек          | O(1)              | Постфиксные выражения, рекурсия|
| Pop                   | Удаление верхнего элемента из стека | O(1)              | Обратные операции              |
| Peek                  | Просмотр верхнего элемента стека    | O(1)              | Проверка верхнего элемента     |

**Использование:** Используются в алгоритмах обратной польской записи, управлении вызовами функций (рекурсия), обработке выражений.

### Очереди (Queues)

**Описание:** FIFO (First In, First Out) структура данных, где первый добавленный элемент извлекается первым.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Enqueue               | Добавление элемента в очередь       | O(1)              | Управление задачами, буферизация|
| Dequeue               | Удаление первого элемента из очереди| O(1)              | Обработка запросов, очереди задач|
| Peek                  | Просмотр первого элемента в очереди | O(1)              | Проверка следующего элемента   |

**Использование:** Подходят для управления задачами, обработки очередей событий, реализации буферов.

### Деки (Deques)

**Описание:** Двусторонняя очередь, где элементы могут добавляться и извлекаться с обоих концов.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Add to Front          | Добавление элемента в начало        | O(1)              | Алгоритмы поиска, буферы       |
| Add to Rear           | Добавление элемента в конец         | O(1)              | Управление задачами, двусторонние очереди |
| Remove from Front     | Удаление первого элемента           | O(1)              | Удаление из начала             |
| Remove from Rear      | Удаление последнего элемента        | O(1)              | Удаление из конца              |

**Использование:** Полезны в алгоритмах поиска, двусторонних очередях задач, управлении состоянием.

### Множества (Sets)

**Описание:** Коллекция уникальных элементов, без определенного порядка.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Add                   | Добавление элемента в множество     | O(1)              | Удаление дубликатов            |
| Remove                | Удаление элемента из множества      | O(1)              | Управление уникальными значениями |
| Contains              | Проверка наличия элемента в множестве | O(1)             | Быстрая проверка принадлежности|

**Использование:** Часто используются для удаления дубликатов, проверки уникальности элементов, реализации математических операций.

### Словари (Dictionaries/Hash Tables)

**Описание:** Коллекция пар "ключ-значение", где каждый ключ уникален.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Insert                | Вставка пары "ключ-значение"        | O(1)              | Быстрый доступ по ключу        |
| Remove                | Удаление пары по ключу              | O(1)              | Управление коллекцией данных   |
| Search                | Поиск значения по ключу             | O(1)              | Доступ по уникальному ключу    |

**Использование:** Применяются для хранения и быстрого доступа к данным по уникальным ключам.

## 3. Деревья (Trees)

### Двоичные деревья (Binary Trees)

**Описание:** Дерево, где каждый узел имеет не более двух дочерних узлов.

**Описание:**  
Двоичное дерево — это структура данных, где каждый узел имеет не более двух дочерних узлов. Дочерние узлы называются левым и правым ребенком. 

**Основные особенности:**
- **Неупорядоченность:** Дочерние узлы могут не следовать какому-либо порядку относительно родительского узла.
- **Гибкость структуры:** Может использоваться для различных целей, не обязательно связанных с упорядоченными данными.
  - Используются для представления иерархий (например, файловые системы).

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Insert                | Вставка элемента                    | O(log n)          | Упорядоченное хранение данных  |
| Delete                | Удаление элемента                   | O(log n)          | Управление структурой данных   |
| Search                | Поиск элемента                      | O(log n)          | Быстрый поиск                  |

**Использование:** Применяются в реализации баз данных, компиляторов, систем обработки запросов.

### Двоичные деревья поиска (Binary Search Trees)

**Описание:** Двоичное дерево, где левый потомок меньше родителя, а правый больше.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Insert                | Вставка элемента                    | O(log n)          | Хранение отсортированных данных|
| Delete                | Удаление элемента                   | O(log n)          | Поддержание структуры          |
| Search                | Поиск элемента                      | O(log n)          | Быстрый доступ к данным        |

**Использование:** Используются для хранения отсортированных данных и выполнения операций поиска.

### Кучи (Heaps)

**Описание:** Двоичное дерево, где родитель всегда больше или меньше своих дочерних узлов (Max-Heap и Min-Heap).

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Insert                | Вставка элемента                    | O(log n)          | Управление приоритетными задачами|
| Delete                | Удаление корневого элемента         | O(log n)          | Извлечение максимума или минимума |
| Peek                  | Просмотр корневого элемента         | O(1)              | Быстрый доступ к приоритетному элементу |

**Использование:** Реализация приоритетных очередей, алгоритмы сортировки (Heapsort).

### AVL-деревья (AVL Trees)

**Описание:** Сбалансированные двоичные деревья поиска, где высота поддеревьев отличается не более чем на 1.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Insert                | Вставка элемента с балансировкой    | O(log n)          | Сбалансированное хранение данных |
| Delete                | Удаление элемента с балансировкой   | O(log n)          | Поддержание сбалансированности |
| Search                | Поиск элемента                      | O(log n)          | Быстрый доступ к данным        |

**Использование:** Применяются в ситуациях, где требуется гарантированная сбалансированность дерева, как в базах данных.

### B-деревья (B-Trees)

**Описание:** Сбалансированные многопутевые деревья, часто используемые в базах данных и файловых системах.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Insert                | Вставка элемента с балансировкой    | O(log n)          | Эффективное управление большими данными |
| Delete                | Удаление элемента с балансировкой   | O(log n)          | Оптимизированное удаление      |
| Search                | Поиск элемента                      | O(log n)          | Быстрый доступ к данным        |

**Использование:** Широко используются в файловых системах и базах данных для управления большими объемами данных.

### Trie (Префиксные деревья)

**Описание:** Дерево, где каждый узел представляет один символ строки, обычно используется для хранения словарей и автодополнения.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Insert                | Вставка строки                      | O(m)              | Хранение и поиск строк         |
| Delete                | Удаление строки                     | O(m)              | Управление словарями           |
| Search                | Поиск строки                        | O(m)              | Быстрый поиск по префиксу      |

**Использование:** Применяются в автодополнении, хранении и поиске слов, словарях.

## 4. Графы (Graphs)

### Неориентированные графы (Undirected Graphs)

**Описание:** Графы, где ребра не имеют направления.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Add Edge              | Добавление ребра                    | O(1)              | Построение графов              |
| Remove Edge           | Удаление ребра                      | O(1)              | Изменение структуры графа      |
| Search (DFS/BFS)      | Поиск в глубину/ширину              | O(V + E)          | Обход графа                    |

**Использование:** Социальные сети, картографические приложения, моделирование сетей.

### Ориентированные графы (Directed Graphs)

**Описание:** Графы, где ребра имеют направление.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Add Edge              | Добавление ориентированного ребра   | O(1)              | Построение ориентированных графов |
| Remove Edge           | Удаление ориентированного ребра     | O(1)              | Изменение структуры графа      |
| Search (DFS/BFS)      | Поиск в глубину/ширину              | O(V + E)          | Обход графа                    |

**Использование:** Потоковые задачи, управление проектами (графы зависимостей), анализ социальных сетей.

### Взвешенные графы (Weighted Graphs)

**Описание:** Графы, где каждому ребру присвоен вес.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Add Edge              | Добавление взвешенного ребра        | O(1)              | Построение графов с весами     |
| Remove Edge           | Удаление взвешенного ребра          | O(1)              | Изменение структуры графа      |
| Dijkstra/Prim's Algorithm | Поиск кратчайшего пути, минимального остовного дерева | O(E + V log V) | Оптимизация маршрутов, минимальные остовные деревья |

**Использование:** Оптимизация маршрутов, транспортные сети, сети коммуникаций.

### Ациклические графы (DAGs)

**Описание:** Ориентированные графы, не содержащие циклов.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Topological Sort      | Топологическая сортировка           | O(V + E)          | Планирование задач, графики    |
| Add Edge              | Добавление ребра                    | O(1)              | Построение DAG                 |
| Remove Edge           | Удаление ребра                      | O(1)              | Изменение структуры DAG        |

**Использование:** Планирование задач, управление зависимостями, компиляторы.

## 5. Специализированные структуры данных

### Хеш-таблицы (Hash Tables)

**Описание:** Структура данных, использующая хеш-функцию для быстрого доступа к данным.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Insert                | Вставка элемента                    | O(1)              | Быстрый доступ по ключу        |
| Remove                | Удаление элемента                   | O(1)              | Управление коллекцией данных   |
| Search                | Поиск элемента по ключу             | O(1)              | Доступ по уникальному ключу    |

**Использование:** Используются для реализации словарей, хранения и быстрого доступа к данным по уникальным ключам.

### Кучи Фибоначчи (Fibonacci Heaps)

**Описание:** Расширение обычных куч, оптимизированное для определённых операций.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Insert                | Вставка элемента                    | O(1)              | Алгоритмы оптимизации          |
| Find Min              | Поиск минимального элемента         | O(1)              | Поддержание минимального элемента |
| Decrease Key          | Уменьшение ключа                    | O(1)              | Оптимизация графов             |
| Delete                | Удаление элемента                   | O(log n)          | Управление приоритетными задачами |

**Использование:** Используются в алгоритмах на графах, таких как алгоритм Дейкстры, для оптимизации времени выполнения.

### Skip Lists (Скользящие списки)

**Описание:** Альтернатива сбалансированным деревьям, использующая несколько уровней связных списков.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Insert                | Вставка элемента                    | O(log n)          | Альтернатива деревьям          |
| Delete                | Удаление элемента                   | O(log n)          | Оптимизированное удаление      |
| Search                | Поиск элемента                      | O(log n)          | Быстрый доступ к данным        |

**Использование:** Используются как альтернатива сбалансированным деревьям, в базах данных и кешировании.

### Bloom Filters (Фильтры Блума)

**Описание:** Пространственно-эффективная вероятностная структура данных, используемая для проверки принадлежности элемента множеству.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Insert                | Добавление элемента                 | O(k)              | Пространственно-эффективное хранение |
| Search                | Проверка принадлежности элемента    | O(k)              | Быстрый тест на принадлежность |
| False Positive Rate   | Вероятность ложноположительного результата | -               | Настраивается                  |

**Использование:** Используются в системах кеширования, базах данных, сетевой безопасности для быстрой проверки на принадлежность без хранения данных.

### Реальные временные деревья (Persistent Data Structures)

**Описание:** Структуры данных, которые сохраняют предыдущие версии своих состояний.

| Метод                 | Описание                            | Сложность (Big O) | Применение                     |
|-----------------------|-------------------------------------|-------------------|--------------------------------|
| Insert                | Вставка элемента                    | O(log n)          | Управление версиями данных     |
| Delete                | Удаление элемента                   | O(log n)          | Поддержание нескольких версий  |
| Search                | Поиск элемента                      | O(log n)          | Доступ к историческим данным   |

**Использование:** Применяются в системах контроля версий, истории изменений, многопользовательских системах.

---

### Заключение

Структуры данных являются ключевым элементом программирования и помогают в создании эффектив
