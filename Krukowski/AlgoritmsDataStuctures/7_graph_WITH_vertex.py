class Vertex:
    """
    __init__(self, value): Инициализирует вершину с заданным значением и пустым списком смежных вершин.
    add_adjacent_vertex(self, vertex): Добавляет смежную вершину, создавая ребро между текущей вершиной и заданной вершиной.
    __str__(self): Возвращает строковое представление вершины и списка её смежных вершин.
    """

    def __init__(self, value):
        """
        Инициализация вершины.

        :param value: Значение вершины.
        """
        self.value = value  # Значение вершины (например, метка или данные или имя пользователя(соц.сети))
        self.adjacent_vertices = []  # Список смежных вершин (связи)

    def add_adjacent_vertex(self, vertex):
        """
        Добавление смежной вершины (ребро) к текущей вершине.

        подписка в соц.сети, добавление в друзья

        :param vertex: Вершина, с которой создается связь.
        """
        # 2.что б не зациклилось рекурсия на добавление в ответ ребра(двойнаправленность ребр), то добавим условие
        if any(v.value == self.value for v in vertex.adjacent_vertices):
            print(f"{self.value} уже есть в списке друзей у {vertex.value}")
            return

        # 0
        self.adjacent_vertices.append(vertex)  # Добавление вершины в список смежных вершин

        # 1.option to connect in react. что б сделать двунапрваленные связи
        vertex.adjacent_vertices.append(self)

    def dfs(self, visited=None):
        """
        Depth-first search - 1ый алгоритм поиска для Графа (поиск в глуибну по графа)

            A
          / | \
         K  B  J
         \ /    \
          D      G
                  \
                  I

        (предпологаем двунаправленность граней, что реализовано в add_adjacent_vertex)

        Хочу выполнить поиск относительно узла А(Alice)
            - начнем перебирать смежные вершины для A, начиная с К(kelly)
                - потом мы понимаем что у К в друзьях есть D(David):
                    - добавляем его в список найденных
                - у D есть в друзьях B (Bob)
                    - его тоже добавляем в список найденных
                - у B смежные узлы только D and A
                - т.к. мы УЖЕ знаем про  D and A  (они УЖЕ в списке найденных)
                -, поэтому на этом ветка поиска завершается.
            - вернувшись к вершине A, переходим ко второй смежной вершине — J (John).
                - У J есть один друг — G (George).
                - У G есть один друг — I (Isaac).
                - У I нет новых друзей, поэтому ветка поиска на этом завершается.
            - Возвращаемся к вершине A, и так как все смежные вершины были посещены, DFS завершен.

        Схема (A - Alice, B - Bob, K - Kelly, D - David, J - John, G - George, I - Isaac):

          A
         / \
        K   J
        |    \
        D     G
         \     \
          B     I
         /
        (уже посещено)

        В результате DFS должны быть посещены все вершины, которые связаны с начальной вершиной A (Alice).

        Метод будет выводить последовательность посещения вершин.
        """
        if visited is None:
            visited = set()  # Инициализация множества посещенных вершин

        visited.add(self)  # Добавление текущей вершины в множество посещенных
        print(self.value)  # Вывод значения текущей вершины

        for adjacent_vertex in self.adjacent_vertices:
            if adjacent_vertex not in visited:
                adjacent_vertex.dfs(visited)  # Рекурсивный вызов для непосещенных вершин

    def __str__(self):
        """
        Строковое представление вершины и её связей.
        """
        return f"{self.value} connected to: {[v.value for v in self.adjacent_vertices]}"


# Создание вершин
alice = Vertex("Alice")
bob = Vertex("Bob")
john = Vertex("John")
kelly = Vertex("Kelly")
david = Vertex("David")
george = Vertex("George")
isaac = Vertex("Isaac")

# Добавление ребер
alice.add_adjacent_vertex(bob)
bob.add_adjacent_vertex(john)
kelly.add_adjacent_vertex(david)
david.add_adjacent_vertex(bob)
alice.add_adjacent_vertex(john)
john.add_adjacent_vertex(george)
george.add_adjacent_vertex(isaac)

print(alice)
print(bob)
print(john)
print(kelly)

# Запуск DFS от вершины Alice
alice.dfs()

print('s')

class Graph:
    """
    __init__(self): Инициализирует граф с пустым словарем для хранения вершин.
    add_vertex(self, value): Добавляет вершину в граф и возвращает созданную вершину.
    add_edge(self, from_vertex, to_vertex): Добавляет ребро между двумя вершинами графа.
    get_vertices(self): Возвращает список всех вершин графа.
    __str__(self): Возвращает строковое представление всего графа.

    Пример использования:
        Добавление вершин и ребер: Создаются вершины A, B, C, D и ребра между ними.
        Вывод графа: Печатается структура графа, показывающая вершины и их связи.
    """
    def __init__(self):
        """
        Инициализация графа.
        """
        self.vertices = {}  # Словарь для хранения вершин графа

    def add_vertex(self, value):
        """
        Добавление вершины в граф.

        :param value: Значение вершины.
        :return: Созданная вершина.
        """
        if value not in self.vertices:
            vertex = Vertex(value)
            self.vertices[value] = vertex
            return vertex
        return None

    def add_edge(self, from_vertex, to_vertex):
        """
        Добавление ребра между двумя вершинами.

        :param from_vertex: Начальная вершина.
        :param to_vertex: Конечная вершина.
        """
        if from_vertex in self.vertices and to_vertex in self.vertices:
            self.vertices[from_vertex].add_adjacent_vertex(self.vertices[to_vertex])

    def get_vertices(self):
        """
        Возвращает все вершины графа.

        :return: Список всех вершин.
        """
        return list(self.vertices.values())

    def __str__(self):
        """
        Строковое представление графа.
        """
        result = ""
        for vertex in self.get_vertices():
            result += str(vertex) + "\n"
        return result


# Пример использования:
g = Graph()

# Добавление вершин
g.add_vertex('A')
g.add_vertex('B')
g.add_vertex('C')
g.add_vertex('D')

# Добавление ребер
g.add_edge('A', 'B')
g.add_edge('A', 'C')
g.add_edge('B', 'D')
g.add_edge('C', 'D')

# Вывод графа
print("Граф:")
print(g)

# Вывод всех вершин и их связей
for vertex in g.get_vertices():
    print(vertex)

"""
Основные отличия между подходами с классом Vertex и без него:
----------------------|--------------------------------------------------------------------|-------------------------------------------------------|
Характеристика        | С классом Vertex                                                   | Без класса Vertex                                     |
----------------------|--------------------------------------------------------------------|-------------------------------------------------------|
Инкапсуляция данных   | Каждый узел (вершина) представлен объектом класса Vertex,          | Вершины представлены ключами в словаре,               |
                      | который инкапсулирует данные и методы.                             | связи (ребра) — списками или словарями.               |
----------------------|--------------------------------------------------------------------|-------------------------------------------------------|
Расширяемость         | Легко добавлять новые методы и атрибуты, например,                 | Расширение функционала может потребовать изменений в  |
                      | для расчета степени вершины или хранения дополнительных данных.    | нескольких местах кода, что усложняет поддержку.      |
----------------------|--------------------------------------------------------------------|-------------------------------------------------------|
Управление связями    | Вершина хранит свои связи в виде словаря,                          | Связи управляются через списки или словари,           |
                      | где ключи — объекты других вершин, что упрощает управление связями.| где хранятся идентификаторы вершин, что менее гибко.  |
----------------------|--------------------------------------------------------------------|-------------------------------------------------------|
Простота использования| Объектно-ориентированный подход может показаться сложнее,          | Простой и прямолинейный подход, легче для понимания   |
                      | но он предоставляет более чистую и модульную структуру.            | и прототипирования, но менее объектно-ориентированный.|
----------------------|--------------------------------------------------------------------|-------------------------------------------------------|
Заключение            | Подходит для больших проектов, где требуется гибкость              | Подходит для небольших проектов,                      |
                      | и расширяемость.                                                   | где важна простота и быстрота реализации.             |
"""

