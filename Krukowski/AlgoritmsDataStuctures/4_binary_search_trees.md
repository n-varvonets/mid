### 1 В отсортированном массиве: 
 - поиск (ОЧЕНЬ БЫСТРО)
 - insert/deletion (ЗАТРАТНО,т.к. еще свдинуть все елементы нужно)

Бинарный поиск как с МАСИВАМИ(на каждом шаге отсекается половина элементов)
<img src="imgs/img_7.png" width="300" height="250">

### 2. Но есть и другая структура данных <u>как binary search trees (BST)</u>.

![img.png](imgs/img_8.png)
Эта структура позволяет эффективно искать, добавлять и удалять элементы.
  1.  SEARCH- (O(log n)), при сбалансированом дереве....Например,Хотим найти 20, что делать?
- при опускании на 1 лвл вниз - отcекаем тогже половину
- log_2(N) ~ 3... <u>(если посчитать, то 7 узлов и 3 уровня, т.е. log_2(7узлов) = 3 шага/лвл</u>
- array  log_2(N)  == BST log_2(N)  - одинковово, в лучшем случае. Поэтому. сначала строим баланс дерево,
а потом делаем поиск. Одинковые значения - НЕДОПУСТИМЫ.

2. Deletion - НЕОЧЕВИДНАЯ логика. Rules:
   1. **Поиск узла для удаления**: 
      - Сначала необходимо найти узел, который нужно удалить. Поиск осуществляется аналогично стандартному поиску элемента в дереве.

   2. **Удаление узла <u>без потомков</u>**:
      - Если узел не имеет потомков, его можно безопасно удалить без каких-либо последствий для структуры дерева.

   3. **Удаление узла <u>с одним потомкомв</u>**:
      - Если у узла есть ТОЛЬКО ОДИН ПОТОМОК (левый или правый), этот потомок заменяет удаляемый узел в дереве.

   4. **Удаление узла <u>с двумя потомкамив</u>**:
      - В этом случае необходимо найти узел-преемник для поддержания корректности структуры дерева:
        - **Преемник** — это наименьший узел в правом поддереве удаляемого узла.
          - т.к. Наименьший узел в правом поддереве будет следующим значением в порядке возрастания (in-order traversal), то есть ближайшим к удаляемому значению, но больше его.
        - **Перенос значения преемника**: Значение преемника переносится в удаляемый узел, заменяя его значение.
        - **Удаление преемника**: После переноса значения, преемник удаляется из его текущего места. Преемник либо является листом (не имеет потомков), либо имеет только правого потомка, который встает на его место.


``` 
Допустим, у нас есть следующее дерево, и мы хотим удалить узел со значением 70: 
1. бинарное дерево поиска до удаления узла:
        50
       /  \
     30    70
    /  \   /  \
   20  40 60  80
              /
             75
            /  \
           72  77

Шаг 1: Находим узел со значением 70.
Шаг 2: Преемником узла 70 является узел 72 (наименьший в правом поддереве).
Шаг 3: Переносим значение 72 в узел 70.
Шаг 4: Удаляем узел 72, так как его значение уже используется.

2. Итоговое дерево будет выглядеть так:
        50
       /  \
     30    72
    /  \   /  \
   20  40 60  80
             /
            75
              \
               77
               
3. Описание:
- После удаления узла 70, его заменил узел 72 (самый левый потомок узла 75),
что позволяет сохранить структуру дерева.
- Узел 75 остался на своем месте, и его правый потомок 77 также остался неизменным.
- Таким образом, дерево остается сбалансированным и соответствует
свойствам бинарного дерева поиска.
```
![img.png](imgs/img_10.png)


### Почему балансировка важна?  
- Если бинарное дерево поиска не сбалансировано, оно может выродиться в список, и тогда его производительность <u>станет аналогичной линейному поиску</u> с временной сложностью O(n).
- В сбалансированном дереве операции выполняются за время O(log n), что сопоставимо с бинарным поиском на массиве.
- получилось несбалансированное дерево на 1млн записей.. как его сделать сбалансрованнным?
  - Один из простейших способов — преобразовать дерево в отсортированный массив, а затем на его основе построить сбалансированное дерево. 
