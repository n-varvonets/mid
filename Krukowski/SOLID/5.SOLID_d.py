#1.#################### [S]INGLE RESPONSIBILITY #####################
# # - каждый класс должен иметь одну и только одну причину для изменения
# # -- и причина изменений может быть **заинтересованное лицо**
# # --- т.е. если приложение разрабатывается и оно нужно АДМИНУ, ОПЕРАТОРУ и КЛИЕНТУ, то
# # --- нужно делать модули так, что б елс АДМИН попросил внести какую-то фичу, то ОНА НЕ ЛОШЛЖНА ПОВЛИЯТЬ на других **заинтересованных лиц**

# правильно назначая ответсвенность/ОБЯЗАННОСТИ обьекту
# проблема задачи была в том что что у менеджера была двойная ответсвенность..
# - он задачами управлял
# - и отвечал за начисление зп.. не правильно
# Или еще пример
# -пришем программу, которая моделириует торговлю молоком, то "где должна быть цена  о стоимости пакета мололка при ООП дизейне?"
# - цена должна ли быть классе Оредер или классе пакет Молокп?
# - если в пакете Молока, то это неправильно, ведь молоку пофиг, а диструбютер может быть разный от степени жадности, где 1$, где 2$,


#2.#################### [O]PEN/CLOSED #####################
# - про наследование(расшряешь функциональность потомком), а не модификацию(внутри искомого класса)
# - не про наследование, нно про расширение функциональност - КОМПОЗИЦИЯ, по сравнению наследования:
# --- плюсы(обьекты становятся не такими зависимоми друг от друга, т.е. более слабая связь между ними, как следствие
# ----- легче масштабировать и вносить новый функционал НЕ СТРОЯ огромную иерархическую структуру
# --- минусы: тот же самый плюс, если не правильно применять, то все будет разбито и не будет связи

#3.#################### [L]ISKOV SUBSTITUTION(ПОДСТАВИВ) #####################
# - инстанс родительского класса можно ВСЕГДА заменить на инстанс дочернего класса(ПОДСТАВИВ)
# - через конкретизацию атрибутов и методов в родительском классе (чтобы избежать проблем, связанных с отсутствием
# унифицированного подхода обработке данных, т.е. для возможности перебора в цикле инстансов род и дочернего класса)

#4.#################### [I]NTERFACE SEGREGATION #####################
# - Класс потомка не должен зависеть от ненужных методов родительского класса.
# - Решение:
# --- создаём миксины — небольшие классы с отдельными методами, которые наследуем только тогда, когда они нужны.т.е. подключать только нужные интрфейсы
# --- через "КОМПОЗИЦИИ" - способ построения объектов, при котором один объект включает в себя другие
# объекты(через передачу в конструктор обьекта) и использует их для выполнения своих задач. ЭТО ДАЖЕ УДОБНЕЙ ЧЕМ наследование МИКСинов.

#5.#################### [D]EPENDENCY INVERSION #####################
# 5.1 Высокоуровневые модули не должны зависеть от низкоуровневых модулей. Оба должны зависеть от абстракций.
# 5.2. Абстракция не должна зависить от реализации, А НАООБОРОТ - реализация должна зависеть от абстракции

# Низкоуровневые модули, в свою очередь, реализуют эту абстракцию. Таким образом, можно легко заменять низкоуровневые модули,
# не изменяя код высокоуровневого модуля, поскольку он работает с абстракцией, а не с конкретной реализацией.
# Пример:
## 1.1.Работа с базой данных через ORM позволяет бизнес-логике не зависеть от конкретной базы данных (например, PostgreSQL,
# MySQL, SQLite). Вместо этого, программа обращается к абстрактным методам ORM,
# которые сами выбирают, как взаимодействовать с каждой из баз данных.

# 2.1. Представь, что у тебя есть разные игрушечные машинки: одна работает на батарейках, а другая на солнечных панелях.
# Если ты хочешь, чтобы твой пульт управления мог управлять любой из этих машинок, не нужно менять пульт для каждой машинки.
# Вместо этого, все машинки должны использовать одну и ту же кнопку «вперёд» и «назад», которая подходит ко всем пультам.
# 2.2.Теперь бизнес-логика не зависит от конкретной базы данных, а лишь от интерфейса Database.

# 3. Брокеры - микросервеси ненапрямую взаимдействуют друг с другом, а через некую абстракцию(брокера), при том что сервисы не подозревают о существовании друг друга

# - dependancy injection - лучше в метод передавать другой класс, чем в классе использовать напрямую другой класс

# крепкий/добротный - принципы и правила - это все хорошо, но не стоит забывать о здравом смысле,
# т.е. нен стоит быть слишком педантичным и следовать всем правилам и довыдам



# крепкий/добротный - принципы и правила - это все хорошо, но не стоит забывать о здравом смысле,
# т.е. нен стоит быть слишком педантичным и следовать всем правилам и довыдам

# --- Problem ---
# - более высокуровневые модули, не должны зависить от более низкоуровевых модулей,
# - а в идеале они должны зависиь от абстракций, при том что
# -- абракции не должны зависить от делателей,а наооборот.. детали должны зависить от абстракций
import sys
import time


# 1. Есть два класса, которые умеют печатать сообщения
# - либо в терминал
# - либо в файл
# 2. Есть логер класс  с
# - автодатой, как префикс
# - и два метода, которые "печатают мсдж в НУЖНОЕ МЕСТО(используя чужие классы)" - ЭТО и есть нарушение DEPENDENCY INVERSION...почему?
class TerminalPrinter:
    def write(self, msg):
        sys.stderr.write(f"{msg}\n")

class FilePrinter:
    def write(self, msg):
        with open('log.txt', 'a+', encoding='UTF8') as f:
            f.write(f"{msg}\n")

class Logger:
    """
    Потмому что данный класс ЗАВИСИТ от 2х ДРУГИХ классов,
    и нету какой-то абстрацкции которая умеет печатать и ВСЕ!

    Т.е. должын обьязатолкьо:
    - классы TerminalPrinter и FilePrinter
    - так у них обьязательно должно быть реализованы по методу write...
    т.е. очень много деталей и класс Logger зависит от других деталей
    """
    def __init__(self):
        self.prefix = time.strftime('%Y-%b-%d %H:%M:%S', time.localtime())

    def log_stderr(self, message):
        TerminalPrinter().write(f"{self.prefix} {message}")

    def log_file(self, message):
        FilePrinter().write(f"{self.prefix} {message}")

# --- Solving ---
# 1. TerminalPrinter и FilePrinter - не трогаем, т.к. они не нарушают никаких принципов(SOLI..)
# 2. класс логер будет приниманать абстрацкцию, а не зависит от абстракции

class LoggerSOLID:

    def __init__(self):
        self.prefix = time.strftime('%Y-%b-%d %H:%M:%S', time.localtime())

    def log(self, message, printer):  # printer - абстракция общего действия напчеатать(один в терминал, второй в файл)
        """"
        - у абстракции должен быть реализован метод write()
        - т.е. нам не важно что это будет за к
        ласс, главное что б передваемый класс реализовыал метод write()
        - в программе можно создать таких классов сколько угодно
        """
        # printer.write(f"{self.prefix} {message}")
        printer().write(f"{self.prefix} {message}") # !!! WARN. что б этот метод сработал, нам нужно
        print(f"file {self.prefix} was created")
        # класс FilePrinter вызвать(инициализровать->сделать инстанс)

    # def log_stderr(self, message):
    #     TerminalPrinter().write(f"{self.prefix} {message}")
    #
    # def log_file(self, message):
    #     FilePrinter().write(f"{self.prefix} {message}")


logger = LoggerSOLID()
# logger.log_file('starting_program')  # куже не нужен спецефический метод log_file
logger.log('starting_program', FilePrinter)   # а просто указать интерфейс через какой печатать