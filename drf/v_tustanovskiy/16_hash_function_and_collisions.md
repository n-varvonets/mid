
# Хеширование в Python

## Что такое хеширование?

Хеширование — это процесс преобразования данных в фиксированное числовое значение с помощью хеш-функции. В Python хеширование используется для эффективного хранения и доступа к данным в таких структурах, как **словари (dict)** и **множества (set)**.

### Пример работы функции `hash()`:

```python
a = 256
b = 256
print(a is b)  # True, так как числа от -5 до 256 кэшируются, и a и b ссылаются на один и тот же объект.

a1 = 2572
b1 = 2572
print(a1 is b1)  # False, числа вне диапазона кэширования создают новые объекты в памяти, поэтому a1 и b1 ссылаются на разные объекты.

a2 = hash(256)
b2 = hash(256)
print(a2 is b2)  # True, результат hash(256) равен 256, а числа до 256 кэшируются, поэтому a2 и b2 ссылаются на один и тот же объект.
print(a2)  # 256
print(b2)  # 256

a3 = hash(257)
b3 = hash(257)
print(a3 is b3)  # False, результат hash(257) равен 257, но числа больше 256 не кэшируются, поэтому a3 и b3 — разные объекты.
print(a3)  # 257
print(b3)  # 257
```

### Описание:
**Кэширование** — это процесс, при котором Python _**хранит часто используемые объекты**_ (например, небольшие целые числа и строки) для повторного использования, чтобы уменьшить количество создаваемых объектов в памяти. Это оптимизация памяти и ускорение выполнения программы.

- **Кэширование чисел:** Python кэширует целые числа в диапазоне от -5 до 256. Это значит, что при присвоении значения переменной, равного кэшированному числу, Python возвращает ссылку на один и тот же объект в памяти. Это ускоряет выполнение программы.
- **Хеширование целых чисел:** Для целых чисел функция `hash()` возвращает само число. Например, `hash(256)` вернёт 256, так как это достаточно уникальное и оптимизированное представление числа.
- **Оператор `is`:** Оператор `is` проверяет, ссылаются ли две переменные на один и тот же объект в памяти. В случае кэшируемых целых чисел это будет `True`, иначе — `False`.

## Как решаются коллизии?

### Что такое коллизия?

Коллизия возникает, когда два различных объекта имеют одинаковое хеш-значение. В Python это может произойти, когда хеш-функция возвращает одно и то же значение для разных объектов. Например:

```python
class MyClass:
    def __hash__(self):
        return 42  # У всех объектов этого класса одинаковый хеш

a = MyClass()
b = MyClass()
print(hash(a) == hash(b))  # True, хеши одинаковы
```

### Стратегии решения коллизий:

1. **Метод цепочек (Chaining):**
   При возникновении коллизии объекты с одинаковым хешем добавляются в связанную структуру данных (например, список), которая хранится в соответствующей ячейке хеш-таблицы.

   - Если возникает коллизия, элемент добавляется в список (или другое хранимое множество объектов).
   - Когда нужно найти элемент, программа ищет в списке всех элементов с одинаковым хешем.

2. **Открытая адресация (Open Addressing):**
   Вместо создания цепочки, программа ищет следующую свободную ячейку в хеш-таблице. Существует несколько стратегий для поиска этой свободной ячейки:

   - **Линейное пробирование (Linear Probing):** Если возникает коллизия, программа проверяет следующую ячейку в таблице до тех пор, пока не найдёт свободное место.
   - **Квадратичное пробирование (Quadratic Probing):** Программа использует квадратичную функцию для поиска следующей свободной ячейки.
   - **Двойное хеширование (Double Hashing):** Используются две разные хеш-функции, и в случае коллизии результат второй функции используется для поиска новой позиции.

### Пример цепочек для решения коллизий:

```python
class HashTable:
    def __init__(self):
        self.table = [[] for _ in range(10)]  # Инициализация хеш-таблицы с цепочками

    def _hash(self, key):
        return hash(key) % len(self.table)

    def insert(self, key, value):
        index = self._hash(key)
        self.table[index].append((key, value))

    def get(self, key):
        index = self._hash(key)
        for k, v in self.table[index]:
            if k == key:
                return v
        return None

# Пример использования
hash_table = HashTable()
hash_table.insert('a', 1)
hash_table.insert('b', 2)
hash_table.insert('c', 3)
print(hash_table.get('a'))  # Выведет 1
```

### Заключение:

- Хеширование — это эффективный способ хранения данных для быстрого доступа, особенно в структурах, таких как словари и множества.
- Коллизии являются естественной проблемой при хешировании, но Python использует методы, такие как цепочки и открытая адресация, для их решения.
- Хеш-функция важна, так как она позволяет эффективно организовать данные, особенно для сложных объектов.
