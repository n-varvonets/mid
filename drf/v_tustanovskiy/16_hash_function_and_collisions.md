
# Хеширование в Python

## Что такое хеширование?

Хеширование — это процесс преобразования данных в фиксированное числовое значение с помощью хеш-функции. В Python хеширование используется для эффективного хранения и доступа к данным в таких структурах, как **словари (dict)** и **множества (set)**.

### Пример работы функции `hash()`:

```python
a = 256
b = 256
print(a is b)  # True, так как числа от -5 до 256 кэшируются, и a и b ссылаются на один и тот же объект.

a1 = 2572
b1 = 2572
print(a1 is b1)  # False, числа вне диапазона кэширования создают новые объекты в памяти, поэтому a1 и b1 ссылаются на разные объекты.

a2 = hash(256)
b2 = hash(256)
print(a2 is b2)  # True, результат hash(256) равен 256, а числа до 256 кэшируются, поэтому a2 и b2 ссылаются на один и тот же объект.
print(a2)  # 256
print(b2)  # 256

a3 = hash(257)
b3 = hash(257)
print(a3 is b3)  # False, результат hash(257) равен 257, но числа больше 256 не кэшируются, поэтому a3 и b3 — разные объекты.
print(a3)  # 257
print(b3)  # 257
```

### Описание:
**Кэширование** — это процесс, при котором Python _**хранит часто используемые объекты**_ (например, небольшие целые числа и строки) для повторного использования, чтобы уменьшить количество создаваемых объектов в памяти. Это оптимизация памяти и ускорение выполнения программы.

- **Кэширование чисел:** Python кэширует целые числа в диапазоне от -5 до 256. Это значит, что при присвоении значения переменной, равного кэшированному числу, Python возвращает ссылку на один и тот же объект в памяти. Это ускоряет выполнение программы.
- **Хеширование целых чисел:** Для целых чисел функция `hash()` возвращает само число. Например, `hash(256)` вернёт 256, так как это достаточно уникальное и оптимизированное представление числа.
- **Оператор `is`:** Оператор `is` проверяет, ссылаются ли две переменные на один и тот же объект в памяти. В случае кэшируемых целых чисел это будет `True`, иначе — `False`.

## Как решаются коллизии?

### Что такое коллизия?

Коллизия возникает, когда два различных объекта имеют одинаковое хеш-значение. В Python это может произойти, когда хеш-функция возвращает одно и то же значение для разных объектов. Например:

```python
class MyClass:
    def __hash__(self):
        return 42  # У всех объектов этого класса одинаковый хеш

a = MyClass()
b = MyClass()
print(hash(a) == hash(b))  # True, хеши одинаковы
```


# Стратегии решения коллизий

## 1. Метод цепочек (Chaining)

Этот метод использует списки для хранения нескольких объектов, которые имеют одинаковый хеш. Если возникает коллизия, новые элементы добавляются в список, связанный с этой ячейкой. Когда необходимо найти элемент, программа перебирает все элементы в списке и возвращает нужный.

### Пример кода:

```python
class HashTable:
       

    def __init__(self):
        # Инициализация хеш-таблицы с 10 пустыми списками (для каждого хеш-значения создается список)
        """
        Если у вас 15 элементов, то их хеш-значения распределятся по 10 корзинам (спискам).
        Некоторые корзины будут хранить более одного элемента.
        
        количества элементов, применяется стратегия динамического расширения (rehashing),
        которая увеличивает количество корзин и перераспределяет существующие элементы по новым корзинам.
        
        В текущем примере нет ограничений на количество значений — можно вставить гораздо больше 10 элементов. 
        Количество списков (корзин) — 10, но каждый список может хранить несколько элементов.
        """
        
        self.table = [[] for _ in range(10)]

    def _hash(self, key):
        # Вычисляем хеш ключа и берем остаток от деления на размер таблицы
        return hash(key) % len(self.table)

    def insert(self, key, value):
        # Находим индекс (хеш) для ключа
        index = self._hash(key)
        # Добавляем ключ и значение в соответствующий список
        self.table[index].append((key, value))

    def get(self, key):
        # Находим индекс (хеш) для ключа
        index = self._hash(key)
        # Перебираем все элементы в списке с одинаковым хешем и ищем нужный ключ
        for k, v in self.table[index]:
            if k == key:
                return v
        return None  # Если ключ не найден
```

### Пример использования:

```python
hash_table = HashTable()
hash_table.insert('a', 1)  # Вставляем ключ 'a' со значением 1
hash_table.insert('b', 2)  # Вставляем ключ 'b' со значением 2
hash_table.insert('c', 3)  # Вставляем ключ 'c' со значением 3

print(hash_table.get('a'))  # Выведет 1, так как ключ 'a' связан с этим значением
```

## 2. Открытая адресация (Open Addressing)

Вместо использования списка для хранения нескольких объектов с одинаковым хешем, программа ищет следующую свободную ячейку в таблице. Если ячейка занята, программа продолжает поиск по определённой стратегии.

### Стратегии открытой адресации:

- **Линейное пробирование (Linear Probing):** Если возникает коллизия, программа проверяет следующую ячейку в таблице до тех пор, пока не найдёт свободное место.
- **Квадратичное пробирование (Quadratic Probing):** Программа использует квадратичную функцию для поиска следующей свободной ячейки.
- **Двойное хеширование (Double Hashing):** Используются две разные хеш-функции, и в случае коллизии результат второй функции используется для поиска новой позиции.


### Заключение:

- Хеширование — это эффективный способ хранения данных для быстрого доступа, особенно в структурах, таких как словари и множества.
- Коллизии являются естественной проблемой при хешировании, но Python использует методы, такие как цепочки и открытая адресация, для их решения.
- Хеш-функция важна, так как она позволяет эффективно организовать данные, особенно для сложных объектов.


---


# Какие типы данных могут быть ключами в словарях Python?

В Python для использования объекта в качестве **ключа в словаре** (или в **множествах**) объект должен обладать следующими свойствами:

1. **Неизменяемость (immutable):** Ключи должны быть неизменяемыми. Это означает, что их значение не может быть изменено после создания.
2. **Хешируемость (hashable):** Объект должен поддерживать метод `__hash__()`, который возвращает его хеш-значение, и метод `__eq__()`, который позволяет сравнивать объекты.

## Типы данных, которые могут быть ключами

### 1. Числа (`int`, `float`)
Целые числа и числа с плавающей запятой — это хешируемые и неизменяемые объекты.

Пример:
```python
d = {1: 'one', 2: 'two'}
print(d[1])  # 'one'
```

### 2. Строки (`str`)
Строки неизменяемы и хешируемы, поэтому их можно использовать как ключи.

Пример:
```python
d = {'name': 'Alice', 'age': 30}
print(d['name'])  # 'Alice'
```

### 3. Кортежи (`tuple`)
Кортежи тоже неизменяемы и могут быть ключами **если все элементы кортежа также хешируемы**.

Пример:
```python
d = {(1, 2): 'point'}
print(d[(1, 2)])  # 'point'
```

Однако, если кортеж содержит изменяемые объекты (например, список), он не может быть использован как ключ:
```python
t = ([1, 2], 3)
# d = {t: 'value'}  # Ошибка TypeError: unhashable type: 'list'
```

### 4. Булевые значения (`bool`)
Булевы значения `True` и `False` тоже можно использовать как ключи, так как они являются подтипом целых чисел.

Пример:
```python
d = {True: 'yes', False: 'no'}
print(d[True])  # 'yes'
```

### 5. NoneType (`None`)
`None` также является хешируемым и неизменяемым объектом, поэтому его можно использовать как ключ.

Пример:
```python
d = {None: 'no value'}
print(d[None])  # 'no value'
```

## Объекты, которые **не могут** быть ключами

- **Списки (`list`)**
Списки являются **изменяемыми** объектами, и поэтому они не могут быть ключами.
```python
lst = [1, 2, 3]
# d = {lst: 'value'}  # Ошибка TypeError: unhashable type: 'list'
```

- **Множества (`set`)**
Множества также изменяемы, поэтому они не могут быть использованы в качестве ключей.
```python
s = {1, 2, 3}
# d = {s: 'value'}  # Ошибка TypeError: unhashable type: 'set'
```

## Пользовательские объекты как ключи

Вы можете использовать объекты классов как ключи, если они реализуют методы `__hash__()` и `__eq__()`. Пример:
```python
class MyKey:
    def __init__(self, val):
        self.val = val

    def __hash__(self):
        return hash(self.val)

    def __eq__(self, other):
        return self.val == other.val

k1 = MyKey(1)
k2 = MyKey(2)

d = {k1: 'value1', k2: 'value2'}
print(d[k1])  # 'value1'
```

## Заключение

- Ключами могут быть неизменяемые и хешируемые объекты, такие как числа, строки, кортежи, булевы значения и пользовательские объекты, которые реализуют методы `__hash__()` и `__eq__()`.
- Изменяемые объекты (например, списки, множества) не могут быть использованы как ключи.

