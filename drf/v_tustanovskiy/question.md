### Какой SQL-запрос нельзя реализовать в Django ORM?

| **Тип SQL-запроса**                                 | **Реализуемо в Django ORM** | **Описание**                                                                                                                                      |
|-----------------------------------------------------|---------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|
| **Базовые SELECT-запросы**                          | Да                        | Django ORM поддерживает простые SELECT-запросы для выборки данных из одной или нескольких таблиц.                                                            |
| **Агрегатные функции**                              | Да                        | Поддержка функций `SUM`, `COUNT`, `AVG`, `MAX`, `MIN` через методы `annotate()` и `aggregate()`.                                                         |
| **JOIN-запросы**                                    | Да                        | Поддержка `INNER JOIN`, `LEFT JOIN` с использованием связей моделей и методов `select_related()`, `prefetch_related()`.                           |
| **Запросы с WHERE**                                 | Да                        | Поддержка условий фильтрации через методы `filter()`, `exclude()`, `Q()`.                                                                         |
| **GROUP BY**                                        | Да                        | Группировка результатов с использованием `annotate()`.                                                                                            |
| **HAVING с GROUP BY**                               | Да                        | Поддержка `HAVING` с использованием `annotate()` и `aggregate()` в комбинации с `filter()` или `Q()`.                                             |
| **LIMIT и OFFSET**                                  | Да                        | Поддержка ограничения результатов через срезы (`[:10]` для `LIMIT 10`, `[10:20]` для `LIMIT 10 OFFSET 10`).                                       |
| **ORDER BY**                                        | Да                        | Сортировка результатов через метод `order_by()`.                                                                                                  |
| **Подзапросы в WHERE**                              | Частично                  | Поддержка через `Subquery` и `Exists`, но сложные подзапросы могут потребовать использования сырых SQL-запросов.                                   |
| **Подзапросы в SELECT**                             | Нет                       | Django ORM не поддерживает подзапросы в `SELECT` части запроса напрямую.                                                                          |
| **Оконные функции (WINDOW FUNCTIONS)**              | Нет                       | Оконные функции (например, `RANK()`, `ROW_NUMBER()`) не поддерживаются. Используйте сырые SQL-запросы через `raw()`.                               |
| **COMMON TABLE EXPRESSIONS (CTE)**                  | Нет                       | Django ORM не поддерживает CTE (например, `WITH RECURSIVE`). Необходимо использовать сырые SQL-запросы через `raw()`.                              |
| **Полнотекстовый поиск (FULLTEXT SEARCH)**          | Частично                  | Поддержка ограничена и зависит от СУБД (например, PostgreSQL). Для других баз данных может потребоваться использование сырых SQL-запросов.         |
| **UNION и UNION ALL**                               | Нет                       | Django ORM не поддерживает `UNION` и `UNION ALL`. Используйте `raw()` для выполнения таких запросов.                                              |
| **HAVING без GROUP BY**                             | Нет                       | Django ORM требует `GROUP BY` для использования `HAVING`.                                                                                         |
| **Сложные JOIN-запросы с условием в ON**            | Частично                  | Поддержка базовых условий, но сложные условия могут потребовать написания сырых SQL-запросов.                                                     |
| **Сложные фильтрации и аннотации, требующие функций SQL** | Частично                  | Поддерживаются базовые фильтрации, но сложные функции могут потребовать использования `Func`, `ExpressionWrapper` или сырых SQL-запросов.         |


### 1. `select_related()` и `prefetch_related()`

#### `select_related()`
Метод `select_related()` используется для выполнения "жадной" загрузки связанных объектов. Это означает, что Django ORM объединяет (JOIN) таблицы на уровне базы данных и загружает связанные объекты вместе с основной моделью в один запрос. Этот метод подходит, когда у вас есть ForeignKey или OneToOneField и вы хотите избежать дополнительных запросов к базе данных.

**Пример использования:**

```python
# Модели
class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)

# Запрос с использованием select_related()
books = Book.objects.select_related('author').all()

# SQL запрос, который выполняется
# SELECT "book"."id", "book"."title", "book"."author_id", "author"."id", "author"."name" 
# FROM "book" INNER JOIN "author" ON ("book"."author_id" = "author"."id")
