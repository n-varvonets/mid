## 1. что значит атономик реквест в настройках джанги? и как называется такая фича на уровне бд?
   - На уровне базы данных эта фича называется транзакцией. В SQL это соответствует командам BEGIN, COMMIT, и ROLLBACK. **<u>Транзакция — это последовательность операций, которые либо выполняются все вместе, либо не выполняются вовсе.</u>**
     - COMMIT: Фиксация изменений в базе данных.
     - ROLLBACK: Откат всех изменений, если произошла ошибка.
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'mydatabase',
        'USER': 'myuser',
        'PASSWORD': 'mypassword',
        'HOST': 'localhost',
        'PORT': '5432',
        'ATOMIC_REQUESTS': True,  # Автоматическое использование транзакций для каждого запроса
    }
}
```

---

## 2. print(hash('Vitalik')) 
### 2.1.
- какой вывод будет между разными запусками и при одном и том же запуске джанго приложения она будет один ? расскажи про соль , как она защищает и как ее используют и понимают подлинноость введенного значения(к примеру пароля).
-  `соль` - если каждый раз к захешированному паролю добавлять  - `некую СЛУЧАЙНУЮ(НЕ секрктную) СТРОКУ`
- `брутфорс (грубая сила)` - метод угадывания пароля путем перебора всех возможных комбинаций символов
- и `радужные таблицы` -  это предвычисленные таблицы с хешами для разных значений (например, для популярных паролей).
Без соли, если злоумышленник узнает хеш пароля, он может быстро восстановить оригинальный пароль с помощью радужных таблиц.

### 2.2. 
- соль для каждого разная.. Как проходит проверка подлинности пароля с солью?

### 1. Создание пароля:

- Когда пользователь создает или обновляет пароль, система генерирует **случайную соль**.
- Соль добавляется к паролю, и затем это значение хешируется.
- **Хеш пароля и соль** сохраняются в базе данных.

**Пример:**
- Пароль: `password123`
- Соль: `random_salt`
- Хешируем: `hash('password123' + 'random_salt')`
- Сохраняем в базу: `hash` и `random_salt`

### 2. Проверка пароля:

- Когда пользователь пытается войти, введенный пароль хешируется с использованием **соли из базы данных**.
- Система извлекает соль и хеш пароля из базы данных.
- Новый хеш (полученный с введенным паролем и солью) **сравнивается с хешем в базе**.

**Пример:**
- Пользователь вводит: `password123`
- Из базы извлекается: `random_salt` и хеш.
- Хешируем: `hash('password123' + 'random_salt')`
- Сравниваем новый хеш с хешем из базы.

Если хеши совпадают, пароль считается правильным.

---

## Вопрос о безопасности: Что если злоумышленник получит доступ к базе данных?

### Сценарий:
- Злоумышленник видит **соль** и **хеш** пароля пользователя.

### Опасения:
1. **Соль и хеш известны**:
   - Да, злоумышленник может узнать соль и хеш, но это **не означает, что он может легко восстановить пароль**, так как хеши **не хранятся в явном виде**, а только их зашифрованное представление.

2. **Атака методом перебора**:
   - Зная соль, злоумышленник может попытаться подобрать пароль методом грубой силы, используя эту соль.
   - **Медленные хеш-функции**, такие как **PBKDF2, bcrypt, Argon2**, затрудняют эту задачу, делая процесс хеширования более длительным и ресурсоемким.

3. **Защита от атак**:
   - **Соль** делает невозможным использование радужных таблиц. Даже зная соль и хеш, злоумышленник не может напрямую восстановить пароль.
   - **Современные методы защиты**: 
     - Использование медленных хеш-функций.
     - Увеличение количества итераций хеширования.
     - Ограничение числа попыток ввода пароля для защиты от атак перебора.

---

## Пример хеширования с солью в Python:

```python
import hashlib
import os

# Генерация случайной соли
salt = os.urandom(16)

# Пользовательский пароль
password = 'password123'

# Хеширование пароля с солью (100000 итераций для безопасности)
hashed_password = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)

# Сохраняем в базу: hashed_password и salt
print(f"Соль: {salt}")
print(f"Хешированный пароль: {hashed_password}")

# Проверка пароля
def verify_password(stored_password, stored_salt, input_password):
    # Хешируем введенный пароль с той же солью
    new_hashed_password = hashlib.pbkdf2_hmac('sha256', input_password.encode(), stored_salt, 100000)
    
    # Сравниваем хеши
    return new_hashed_password == stored_password

# Пример проверки
print(verify_password(hashed_password, salt, 'password123'))  # True
print(verify_password(hashed_password, salt, 'wrongpassword'))  # False


