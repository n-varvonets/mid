
# Логика изменения объектов: Модель или Менеджер?

<u>есть логика измения обьекта,обьектов.. когда нам лучше ее поместить в модель, а когда в менеджер?</u>

В Django логика изменения объекта или объектов может быть помещена как в модель, так и в менеджер. Выбор между моделью и менеджером зависит от того, как вы планируете использовать эту логику и на что она направлена. Давайте разберем, когда лучше использовать модель, а когда менеджер.

## Когда логика должна быть в **модели**:

Логику стоит помещать в модель, когда:

1. **Логика касается отдельного объекта**: Если изменение или операция непосредственно связаны с изменением состояния одного объекта.
2. **Логика относится к данным объекта**: Логика касается бизнес-правил для одного объекта (например, валидация, изменение поля в зависимости от другого поля и т.д.).
3. **Логика должна быть доступна везде**: Это удобно, когда вы хотите, чтобы эта логика была доступна в любой части системы, где используется объект модели.

### Пример логики в модели:

```python
class Order(models.Model):
    status = models.CharField(max_length=20)
    updated_at = models.DateTimeField(auto_now=True)

    def mark_as_shipped(self):
        # Отмечает заказ как отправленный
        self.status = 'shipped'
        self.save()
```

#### Когда использовать логику в модели:
- Если изменение логически связано с одним конкретным экземпляром модели (например, изменение статуса заказа).
- Если вам нужно вызывать этот метод в разных местах приложения, и он оперирует данными отдельного объекта.

---
 
- **Менеджер**:
  - Используется для работы с набором объектов, когда логика должна оперировать множеством объектов или формировать сложные запросы. Менеджер подходит для методов, которые изменяют данные сразу для нескольких объектов или возвращают набор данных.
  - менеджер - менеджер, который позволяет нам работать с кверисет + дополнительно создавать/переопределять существующие методы.
---

## Пример, объединяющий оба подхода:

```python
class OrderManager(models.Manager):
    def mark_all_as_shipped(self):
        # Отмечает все заказы как отправленные
        return self.filter(status='processing').update(status='shipped')

class Order(models.Model):
    status = models.CharField(max_length=20)
    updated_at = models.DateTimeField(auto_now=True)

    objects = OrderManager()

    def mark_as_shipped(self):
        # Отмечает заказ как отправленный
        self.status = 'shipped'
        self.save()
```

Здесь:
- **Модель** содержит логику для изменения статуса одного заказа.
- **Менеджер** содержит логику для изменения статуса нескольких заказов сразу.


---

# Пример 2 кастомной логики в менеджере

Менеджеры позволяют создавать кастомные методы для работы с набором объектов. Это может быть полезно для фильтрации, модификации или выполнения определенной логики для группы объектов.

## Пример кастомной логики в менеджере

Рассмотрим пример, где мы хотим реализовать метод в менеджере, который будет возвращать все заказы, ожидающие доставки, и помечать их как "обработанные".

### Модель `Order` с кастомным менеджером:

```python
class OrderManager(models.Manager):
    def process_pending_orders(self):
        # Получаем все заказы со статусом "pending"
        pending_orders = self.filter(status='pending')
        
        # Помечаем все заказы как "processed"
        pending_orders.update(status='processed')
        
        # Возвращаем обработанные заказы
        return pending_orders

class Order(models.Model):
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('processed', 'Processed'),
        ('shipped', 'Shipped'),
    ]
    
    status = models.CharField(max_length=10, choices=STATUS_CHOICES)
    updated_at = models.DateTimeField(auto_now=True)

    objects = OrderManager()
```

### Когда использовать кастомную логику в менеджере?

- Когда необходимо работать с **множеством объектов** сразу, например, обновление статусов нескольких заказов.
- Для **удобной фильтрации данных**: в данном примере мы фильтруем заказы со статусом "pending".
- Для создания методов, которые **обрабатывают набор данных** и возвращают результат, как в примере с возвратом обработанных заказов.

### Пример использования кастомного метода:

```python
# Обработка всех заказов со статусом "pending"
processed_orders = Order.objects.process_pending_orders()

for order in processed_orders:
    print(f"Order {order.id} has been processed.")
```

---
## Пример3 ДангоСкул

```python
# Кастомный менеджер для работы с моделью Post
class MyManager(models.Manager):
    
    # Метод фильтрации, который автоматически добавляет условие "published=True"
    def custom_filter(self, **kwargs):
        # Добавляем фильтр по полю "published"
        kwargs['published'] = True
        # Возвращаем фильтрованный набор данных, добавляя любые другие переданные фильтры
        return super().get_queryset().filter(**kwargs)
    
    # Метод сортировки, который автоматически добавляет поле "published" в список сортировки
    def custom_order_by(self, *args):
        # Добавляем "published" в начало списка полей для сортировки
        args = ('published', ) + args
        # Возвращаем отсортированный набор данных по указанным полям
        return super().get_queryset().order_by(*args)

# Модель Post представляет собой публикации
class Post(models.Model):
    # Поле для заголовка поста
    title = models.CharField(max_length=100)
    # Поле для текста поста
    text = models.TextField()
    # Поле для связи с автором (связь с моделью User)
    author = models.ForeignKey(User, on_delete=models.CASCADE, related_name='post')
    # Поле для участников поста (многие-ко-многим связь с моделью User)
    members = models.ManyToManyField(User, related_name="members", blank=True)
    # Булево поле, указывающее, опубликован ли пост
    published = models.BooleanField(default=False)

    # Метод __str__ для представления поста в виде строки (вернет заголовок поста)
    def __str__(self):
        return self.title

# Стандартный менеджер без кастомной логики
objects = models.Manager()

# Кастомный менеджер с дополнительными методами для фильтрации и сортировки
custom_manager = MyManager()

```


## Вывод

Менеджеры — это мощный инструмент для работы с наборами объектов. Создание кастомных методов в менеджере позволяет организовать и повторно использовать логику, которая затрагивает множество объектов, что делает код более структурированным и поддерживаемым.

