
## Вопросы

1. **Что видит middleware в процессе жизни воркера?**
   - **Джанга создает объект middleware для обработки каждого запроса или нет?**
   - **Какой `self` класса middleware будет при обработке двух разных запросов?**

2. **Когда приходят несколько запросов на одну вью, это будет один объект вью или это будут разные объекты вью?**

3. **В чем опасность кастомизировать `dispatch` метод? Может ли он перезатирать данные на уровне классов?**

---

## Ответы

### 1. Что видит middleware в процессе жизни воркера?
   - Django не создает новый объект middleware для каждого запроса. Middleware создаются один раз при запуске приложения. Эти объекты используются повторно для обработки всех запросов.
   - Есть базовые функции `process_request`, `process_response` в обьекте Middleware, которые обрабатывает запросы и ответы при помощи (`__call__`,  и т.д.).
   - Это означает, что `self` для разных запросов будет одинаковым. **Однако каждый запрос будет обрабатываться в своем контексте**, и данные запроса не будут пересекаться между ними, если только вы не храните что-то глобальное на уровне класса.
   - Middleware удобно использовать для логирования всех запросов или модификации заголовков, потому что все запросы проходят через них, и они видят все запросы и ответы.

### 2. Когда приходят несколько запросов на одну вью, это будет один объект вью или это будут разные объекты вью?
- Django создает **новый объект вью (представления)** для каждого входящего запроса. Это означает, что если на одну и ту же вью поступают несколько запросов одновременно, для каждого из этих запросов будет создан свой собственный экземпляр класса вью.
- Это важно для изоляции состояния запроса. Так как каждый запрос обрабатывается в отдельном экземпляре вью, данные не могут пересекаться между запросами, что гарантирует безопасность обработки.

### 3. В чем опасность кастомизировать метод `dispatch`? Может ли он перезатирать данные на уровне классов?
## Опасности кастомизации метода `dispatch` и как избежать проблем

### Опасности кастомизации `dispatch`:

1. **Перезапись данных**:
   - Основная проблема при кастомизации метода `dispatch` заключается в неправильном использовании атрибутов класса, таких как `self`. Эти атрибуты могут **перезаписываться** между запросами.
   - Каждый новый запрос вызывает новый объект представления (вью), но если данные хранятся в атрибутах класса (`self.shared_data`), они могут **разделяться** между всеми запросами, что приведет к неожиданным результатам.

2. **Проблема параллельных запросов**:
   - В многопоточной или многопроцессной среде сервер обрабатывает несколько запросов одновременно. Если использовать общие атрибуты класса для хранения данных в методе `dispatch`, каждый запрос может изменять данные других запросов.
   - Это может стать причиной **конкуренции за ресурсы** и некорректных результатов, так как один запрос может перезаписать данные другого.

### Пример ошибки:

```python
class MyView(View):
    def dispatch(self, request, *args, **kwargs):
        # Пример плохого кода — использование общего атрибута
        self.shared_data = "Some data"  # Этот атрибут будет перезаписываться между запросами
        return super().dispatch(request, *args, **kwargs)
```
### Как правильно кастомизировать dispatch:

```python
class MyView(View):
    """
    Чтобы избежать этой проблемы, не используйте общие атрибуты класса для хранения данных, специфичных для
    каждого запроса. Вместо этого используйте локальные переменные внутри метода dispatch.
    
    Локальные переменные создаются и используются только в рамках одного запроса,
    и они не перезаписываются между запросами.
    """
    def dispatch(self, request, *args, **kwargs):
        # Правильный подход — используем локальные переменные для каждого запроса
        local_data = "Some data"  # Локальная переменная, уникальная для каждого запроса
        
        # Можно добавлять дополнительную логику обработки запроса или манипулировать данными
        if request.method == "GET":
            local_data = "Data for GET request"
        elif request.method == "POST":
            local_data = "Data for POST request"

        # Вызываем стандартный метод dispatch для обработки запроса
        response = super().dispatch(request, *args, **kwargs)

        # После выполнения запроса можем логировать или обрабатывать response
        print(f"Обработан запрос с данными: {local_data}")

        return response
```
### Выводы:

- **Middleware** создается один раз при запуске приложения и используется для обработки всех запросов. Поэтому `self` в middleware будет одинаковым для всех запросов, но каждый запрос будет обрабатываться в своем контексте.
- **View** создается для каждого запроса, что обеспечивает изоляцию запросов и предотвращает утечки данных между ними.
- **Метод `dispatch`** можно кастомизировать, но нужно быть осторожным с изменением данных на уровне класса, чтобы не допустить перезаписи данных между запросами.
