### Код метода `dispatch`:

```python
def dispatch(self, request, *args, **kwargs):
    # Пробуем направить на нужный HTTP-метод, если метод существует
    # Если метода нет, передаем обработку в метод, который возвращает ошибку
    # Если метод запроса не входит в одобренный список
    if request.method.lower() in self.http_method_names:
        # Получаем метод на основе имени HTTP-метода (например, get, post)
        handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
    else:
        # Если метода нет в списке, указываем на метод, что обработает неразрешенные методы
        handler = self.http_method_not_allowed

    # Вызываем обработчик метода с передачей запроса и дополнительных аргументов
    return handler(request, *args, **kwargs)
```
| Описание            | Комментарий |
|---------------------|-------------|
| **Назначение:**     | Метод `dispatch` направляет HTTP-запрос к соответствующему методу представления, например, `get`, `post`, `put` и т.д. |
| **Переопределение:**| Этот метод переопределяют, чтобы гибко управлять маршрутизацией HTTP-запросов, настраивая логику обработки, исходя из методов, которые доступны в контроллере. |
| **Решаемая задача:**| Определяет, какой метод контроллера использовать в зависимости от HTTP-метода запроса (например, `GET`, `POST`), и обрабатывает ошибку, если метод не поддерживается. |

---

- **View**:
  - Проверяет и вызывает корректный HTTP-метод, соответствующий запросу.
  - Сохраняет аргументы `kwargs` для дальнейшего использования.
  - Обеспечивает доступ к объекту `request` через `self` (благодаря методу `setup()`).
  - Гарантирует вызов метода CRUD во вью, соответствующего запросу.


- **ListView**:
  - `Автоматически подготавливает и отображает список объектов из базы данных`, передав в него модель.
  - Поддерживает кастомизацию логики получения объектов через `queryset`(<u>**ТОТ ЗАПРОС, КОТОРЫЙ МЫ ХОТИМ ОТПРАВИТЬ В БАЗУ**</u>). Например:
    - ```python
      class MoviesView(ListView):
          model = Movie
          queryset = Movie.objects.filter(draft=False)  # кастомная логика фильтрации объектов
      ```
  - Поддерживает пагинацию для длинных списков данных.
    - В основе ListView лежит **MultipleObjectMixin**, который предоставляет базовую функциональность для работы с множеством объектов,
      - `включая поддержку фильтрации и сортировки`.
      - **MultipleObjectMixin** также наследуется от **ContextMixin**, `что позволяет добавлять дополнительные данные в контекст`, используемый в шаблонах (см. ниже реализацию `ContextMixin`).
      - <u>**Изменяя атрибуты этого класса (`allow_empty`, `queryset`, `model`, `paginate_by`, `paginate_orphans`, `context_object_name`, `paginator_class`, `page_kwarg`, `ordering`), можно гибко управлять поведением вашего представления.**</u> Это позволяет кастомизировать логику работы программы без необходимости переопределять методы.
        - Например:
          - **`paginate_by`**: Включает или отключает пагинацию, задавая количество объектов на страницу.
          - **`queryset`**: Определяет, какие данные будут извлекаться из базы, заменяя стандартный набор данных модели.
          - **`ordering`**: Управляет сортировкой данных, позволяя задать порядок отображения объектов.
        
        - Этот миксин предоставляет мощный инструмент для настройки работы с множеством объектов, просто изменяя его атрибуты, что делает его гибким и удобным в использовании.
        - ```python
          class MultipleObjectMixin(ContextMixin):
              """
              Mixin для представлений, работающих с несколькими объектами.
              """
      
              allow_empty = True  # Разрешает возвращать пустой список объектов. Если False, будет вызвана ошибка при отсутствии объектов.
              queryset = None  # Набор данных (QuerySet), который будет использован. Если None, будет использоваться модель, определенная в представлении.
              model = None  # Модель, объекты которой будут отображаться. Используется, если queryset не определен.
              paginate_by = None  # Количество объектов на странице при пагинации. Если None, пагинация отключена.
              paginate_orphans = 0  # Количество "сиротских" объектов, которые добавляются на последнюю страницу, чтобы избежать создания пустой страницы.
              context_object_name = None  # Имя переменной контекста, содержащей список объектов. Если None, используется имя модели с суффиксом '_list'.
              paginator_class = Paginator  # Класс пагинатора, используемый для разбиения объектов на страницы. По умолчанию это стандартный Paginator.
              page_kwarg = 'page'  # Имя параметра URL, используемого для определения текущей страницы в пагинации.
              ordering = None  # Определяет порядок сортировки объектов. Если None, используется порядок, заданный в модели или queryset.
      
              def get_queryset(self):
                  """
                  Возвращает список элементов для этого представления.
                  Метод можно переопределить для кастомной логики получения данных.
                  """
                  if self.queryset is not None:
                      queryset = self.queryset  # Если определен queryset, используется он.
                      if isinstance(queryset, QuerySet):
                          queryset = queryset.all()  # Получаем все объекты, если queryset является экземпляром QuerySet.
                  elif self.model is not None:
                      queryset = self.model._default_manager.all()  # Если queryset не определен, используется модель для получения всех объектов.
                  else:
                      raise ImproperlyConfigured(  # Если ни queryset, ни модель не определены, вызывается ошибка конфигурации.
                          "%(cls)s is missing a queryset. Define "
                          "%(cls)s.model, %(cls)s.queryset, or override "
                          "%(cls)s.get_queryset()." % {
                              'cls': self.__class__.__name__
                          }
                      )
                  if self.ordering is not None:
                      queryset = queryset.order_by(*self.ordering)  # Применение сортировки, если она определена.
                  return queryset
      ```

- **DetailView**:
  - Отображает информацию об одном объекте из базы данных.
  - Автоматически получает объект по его первичному ключу (например, ID).
  - Поддерживает получение объекта по `slug` (или другим уникальным полям), если это указано в настройках:
    - ```python
      class MovieDetailView(DetailView):
          model = Movie
          slug_field = 'slug'  # указываем поле из модели, по которому будем искать, мол в модели должен быть аатрибут 
          # slug = models.SlugField(max_lenght=120, unique=True) # можно указать к примеру название аттрибута url/title и прокинуть его как новое
          # в паттерн это указывать (либо slug, либо pk) 
          # urlpatterns = [
          #    path("", views.MoviesView.as_view()),
          #    path("<slug:slug>/", views.MovieDetailView.as_view(), name="movie_detail"),
          #    path("review/<int:pk>/", views.AddReview.as_view(), name="add_review"),
          #]
          #если мы написали catagy в  "<slug:catagy>/", то нам нужно переопределить ключ slug_url_kwarg
          slug_url_kwarg = 'slug'
      ```
  - Таким образом, можно использовать URL слаг для определения конкретного объекта, например, **`/movies/inception/`**.
  - В основе DetailView лежит **SingleObjectMixin**, который `отвечает за получение одного объекта из базы данных` на основе предоставленного ключа (например, `pk` или `slug`).
    - **SingleObjectMixin** также наследуется от **ContextMixin**, что `позволяет добавлять дополнительные данные в контекст`, используемый в шаблонах (см. ниже реализацию `ContextMixin`).
  - Поддерживает работу с контекстом, используя метод `get_context_data()`, который позволяет добавлять дополнительные данные в шаблон.


- **ContextMixin**:
  - Предоставляет базовую функциональность для работы с контекстными данными в представлениях.
  - Основное его использование заключается в методе `get_context_data()`, который позволяет добавить или изменить данные, передаваемые в контекст шаблона. Пример:
    - ```python
      class MyView(ContextMixin, View):
          def get_context_data(self, **kwargs):
              context = super().get_context_data(**kwargs)
              context['extra_data'] = 'Some extra data'
              return context
      ```
  - Контекстные данные, добавленные через этот миксин, будут доступны в шаблоне представления.

- **get_context_data()**:
  - Метод, используемый для передачи дополнительной информации в контекст шаблона.
  - Вызывается в представлениях, наследуемых от `ContextMixin`, для добавления или модификации данных в контексте. Пример:
    - ```python
      class MyDetailView(DetailView):
          model = Movie
          
          def get_context_data(self, **kwargs):
              context = super().get_context_data(**kwargs)
              context['extra_info'] = 'Дополнительная информация'
              return context
      ```
  - Данные, возвращенные из `get_context_data()`, становятся доступными в шаблоне для рендеринга.
