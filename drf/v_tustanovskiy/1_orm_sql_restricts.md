### Какой SQL-запрос нельзя реализовать в Django ORM?

| **Тип SQL-запроса**                                 | **Реализуемо в Django ORM** | **Описание**                                                                                                                                      |
|-----------------------------------------------------|---------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|
| **Базовые SELECT-запросы**                          | Да                        | Django ORM поддерживает простые SELECT-запросы для выборки данных из одной или нескольких таблиц.                                                            |
| **Агрегатные функции**                              | Да                        | Поддержка функций `SUM`, `COUNT`, `AVG`, `MAX`, `MIN` через методы `annotate()` и `aggregate()`.                                                         |
| **JOIN-запросы**                                    | Да                        | Поддержка `INNER JOIN`, `LEFT JOIN` с использованием связей моделей и методов `select_related()`, `prefetch_related()`.                           |
| **Запросы с WHERE**                                 | Да                        | Поддержка условий фильтрации через методы `filter()`, `exclude()`, `Q()`.                                                                         |
| **GROUP BY**                                        | Да                        | Группировка результатов с использованием `annotate()`.                                                                                            |
| **HAVING с GROUP BY**                               | Да                        | Поддержка `HAVING` с использованием `annotate()` и `aggregate()` в комбинации с `filter()` или `Q()`.                                             |
| **LIMIT и OFFSET**                                  | Да                        | Поддержка ограничения результатов через срезы (`[:10]` для `LIMIT 10`, `[10:20]` для `LIMIT 10 OFFSET 10`).                                       |
| **ORDER BY**                                        | Да                        | Сортировка результатов через метод `order_by()`.                                                                                                  |
| **Подзапросы в WHERE**                              | Частично                  | Поддержка через `Subquery` и `Exists`, но сложные подзапросы могут потребовать использования сырых SQL-запросов.                                   |
| **Подзапросы в SELECT**                             | Нет                       | Django ORM не поддерживает подзапросы в `SELECT` части запроса напрямую.                                                                          |
| **Оконные функции (WINDOW FUNCTIONS)**              | Нет                       | Оконные функции (например, `RANK()`, `ROW_NUMBER()`) не поддерживаются. Используйте сырые SQL-запросы через `raw()`.                               |
| **COMMON TABLE EXPRESSIONS (CTE)**                  | Нет                       | Django ORM не поддерживает CTE (например, `WITH RECURSIVE`). Необходимо использовать сырые SQL-запросы через `raw()`.                              |
| **Полнотекстовый поиск (FULLTEXT SEARCH)**          | Частично                  | Поддержка ограничена и зависит от СУБД (например, PostgreSQL). Для других баз данных может потребоваться использование сырых SQL-запросов.         |
| **UNION и UNION ALL**                               | Нет                       | Django ORM не поддерживает `UNION` и `UNION ALL`. Используйте `raw()` для выполнения таких запросов.                                              |
| **HAVING без GROUP BY**                             | Нет                       | Django ORM требует `GROUP BY` для использования `HAVING`.                                                                                         |
| **Сложные JOIN-запросы с условием в ON**            | Частично                  | Поддержка базовых условий, но сложные условия могут потребовать написания сырых SQL-запросов.                                                     |
| **Сложные фильтрации и аннотации, требующие функций SQL** | Частично                  | Поддерживаются базовые фильтрации, но сложные функции могут потребовать использования `Func`, `ExpressionWrapper` или сырых SQL-запросов.         |


## 1. `select_related()` против `prefetch_related()`

### Когда использовать:
- `select_related():` Используйте для получения связанных данных в отношениях `ForeignKey` и `OneToOneField`, когда требуется минимизировать количество SQL-запросов и отношения являются "один к одному" или "многие к одному".
- `prefetch_related():` Используйте для получения связанных данных в отношениях `ManyToManyField` или при необходимости обработки больших объемов связанных данных, где JOIN может быть неэффективен.

### `select_related()`
- **Назначение**: Оптимизирует запросы к базе данных, уменьшая количество SQL-запросов при получении связанных объектов.
- **Использование**: Работает с отношениями `ForeignKey` и `OneToOneField`.
- **Как работает**: Выполняет один SQL-запрос с использованием `JOIN` для получения данных из связанных таблиц.
- **Пример**:

```python
from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)

# Получение всех книг с их авторами
books = Book.objects.select_related('author').all()

for book in books:
    print(book.title, book.author.name)
```
Комментарий: Здесь select_related() сделает один SQL-запрос с JOIN, чтобы сразу получить данные книги и автора. Это эффективно для ForeignKey и OneToOneField, потому что данные связаны "один к одному" или "многие к одному", и JOIN обеспечит быстрый доступ к ним.

### `prefetch_related()`
- **Назначение**: Оптимизирует запросы для получения связанных объектов, особенно когда использование `select_related()` неэффективно.
- **Использование**:  Эффективнее, чем `select_related()` для отношений `ManyToManyField`, потому что JOIN в этом случае может быть медленным и приводить к дублированию данных..
- **Как работает**: Выполняет несколько SQL-запросов: один для основного объекта и дополнительные для связанных объектов.
- **Пример**:

```python
from django.db import models

class Genre(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=100)
    genres = models.ManyToManyField(Genre)

# Получение всех книг с их жанрами
books = Book.objects.prefetch_related('genres').all()

for book in books:
    print(book.title, [genre.name for genre in book.genres.all()])
```
Комментарий: В этом примере используется `prefetch_related()`, чтобы получить жанры для каждой книги. Django 
- сначала выполнит запрос для получения всех книг,
- затем выполнит второй запрос для получения всех жанров, связанных с этими книгами, и уже на уровне Python свяжет их.  

Это предотвращает создание сложных и медленных JOIN операций, которые могут существенно замедлить работу с большими наборами данных.

## 2. `annotate()` против `aggregate()`

### Применение `annotate()` и `aggregate()` к различным типам связей

- **`annotate()`**: Используйте, когда нужно `добавить вычисляемые поля к каждому объекту в выборке`. Например, подсчет количества связанных объектов или вычисление средних значений для каждого объекта.
  - **Использует связанные модели**: `annotate()` может использовать данные из связанных моделей для выполнения вычислений и добавления этих данных к каждому объекту в выборке.


- **`aggregate()`**: Используйте, когда необходимо `выполнить вычисления над всей выборкой и получить единое значение`, например, сумму или среднее значение по полю.
  - **Использует только свою модель**: `aggregate()` выполняет вычисления только по полям текущей модели, не затрагивая данные из связанных моделей.

```python
from django.db import models
from django.db.models import Count, Avg, Sum, Max, Min

class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=100)
    price = models.DecimalField(max_digits=5, decimal_places=2)
    rating = models.FloatField()
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
    
# annotate() примеры
authors = Author.objects.annotate(avg_rating=Avg('book__rating'))
authors = Author.objects.annotate(
    book_count=Count('book'),         # Количество книг
    avg_rating=Avg('book__rating'),   # Средний рейтинг книг
    total_price=Sum('book__price'),   # Общая стоимость книг
    max_price=Max('book__price'),     # Максимальная цена книги
    min_price=Min('book__price')      # Минимальная цена книги
)

# aggregate() примеры
book_aggregates = Book.objects.aggregate(
    total_books=Count('id'),          # Общее количество книг
    average_rating=Avg('rating'),     # Средний рейтинг всех книг
    total_price=Sum('price'),         # Общая стоимость всех книг
    max_price=Max('price'),           # Максимальная цена среди всех книг
    min_price=Min('price')            # Минимальная цена среди всех книг
)

print(book_aggregates)
  ```

## 3. 

- **`Q()`**: Используйте, когда нужно `создать сложные запросы с логическими операциями` (например, AND, OR, NOT). 
  - **Создает условия для фильтрации**: `Q()` позволяет комбинировать различные условия фильтрации и строить запросы с использованием логических операторов.
  - 


- **`F()`**: Используйте, когда нужно `сравнивать поля модели друг с другом или выполнять операции с их значениями прямо в базе данных`.
  - **Работает с полями текущей модели**: `F()` позволяет использовать значения полей модели для вычислений или сравнения внутри одного запроса, например, увеличивать значение поля или сравнивать два разных поля одной модели.

```python
from django.db import models
from django.db.models import Q, F

class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=100)
    price = models.DecimalField(max_digits=5, decimal_places=2)
    rating = models.FloatField()
    author = models.ForeignKey(Author, on_delete=models.CASCADE)

# Примеры использования Q()
# Получение книг, написанных автором с именем "John Doe" или книг с рейтингом выше 4
books = Book.objects.filter(Q(author__name='John Doe') | Q(rating__gt=4))

# Примеры использования F()
# ОШИБКА - Правильнее было бы сравнить price с фиксированным значением или значением из другой таблицы.

# Book.objects.filter(price__lt=F('price') * 0.9).update(price=F('price') * 1.1)
```

#### Вариант 1: Использование фиксированного значения

```python
Book.objects.filter(price__lt=100).update(price=F('price') * 1.1)
```

- **Что делает этот код**:
  - **Условие фильтрации**: `price__lt=100`
    - Этот фильтр находит все книги, у которых цена (`price`) меньше 100. Это фиксированное значение позволяет корректно отфильтровать книги для последующего обновления.
  - **Обновление**: `update(price=F('price') * 1.1)`
    - После фильтрации, функция `update()` увеличивает цену каждой отобранной книги на 10% (`* 1.1`).
  - **Резюме**: Этот код корректно отфильтровывает книги, сравнивая их цену с фиксированным значением (например, 100) и затем увеличивает цену каждой книги на 10%.

#### Вариант 2: Использование значения из другой таблицы

```python
from django.db.models import Subquery, OuterRef

average_price = Book.objects.filter(author=OuterRef('author')).values('author').annotate(avg_price=Avg('price')).values('avg_price')
Book.objects.filter(price__lt=Subquery(average_price)).update(price=F('price') * 1.1)
```

- **Что делает этот код**:
  - **Условие фильтрации**: `price__lt=Subquery(average_price)`
    - Этот фильтр находит все книги, у которых цена (`price`) меньше среднего значения цен книг того же автора (`average_price`). Здесь используется `Subquery` для получения среднего значения цены книг из той же таблицы, что и сама книга, но в контексте того же автора.
  - **Обновление**: `update(price=F('price') * 1.1)`
    - После фильтрации, функция `update()` увеличивает цену каждой отобранной книги на 10% (`* 1.1`).
  - **Резюме**: Этот код корректно сравнивает цену каждой книги с средним значением цены книг того же автора. Если цена книги ниже этого среднего значения, она увеличивается на 10%.

### Пример 2: Получение всех книг, где рейтинг больше или равен цене

```python
books = Book.objects.filter(rating__gte=F('price'))
```

- **Что делает этот код**:
  - **Условие фильтрации**: `rating__gte=F('price')`
    - Этот фильтр находит все книги, у которых рейтинг (`rating`) больше или равен цене (`price`).
  - **Зачем это нужно**:
    - Представьте, что цена книги отражает её качество, и вы хотите найти все книги, где рейтинг соответствует или превышает цену. Этот запрос поможет вам найти такие книги.

- **Как это работает**:
  - `F('price')` позволяет получить текущее значение поля `price` для каждой записи и сравнить его с `rating` для той же записи. Это делается прямо в базе данных, без необходимости загружать данные в Python и обрабатывать их вручную.
  - **Резюме**: Код используется для анализа данных на основе сравнения двух полей внутри одной и той же записи.

```
# Получение всех книг, где рейтинг больше или равен средней цене
books = Book.objects.filter(rating__gte=F('price'))
 ```

- **Что делает этот код №1**:
  - **Условие фильтрации**: `price__lt=F('price') * 0.9`
    - Этот фильтр находит все книги, у которых цена (`price`) меньше 90% от текущего значения этого же поля (`price`). Это кажется странным, но на самом деле здесь ошибка: фильтр всегда вернет пустой набор, потому что `price` всегда равно `price`. Правильнее было бы сравнить `price` с фиксированным значением или значением из другой таблицы.
  - **Обновление**: `update(price=F('price') * 1.1)`
    - После фильтрации, функция `update()` изменяет поле `price` для всех отобранных книг. Значение `price` увеличивается на 10% (`* 1.1`).
  - **Резюме**: Код должен был использовать сравнение с внешней переменной или фиксированной величиной для сравнения с `price`. Текущая реализация является логической ошибкой.


- **Что делает этот код №2**:
  - **Условие фильтрации**: `rating__gte=F('price')`
    - Этот фильтр находит все книги, у которых рейтинг (`rating`) больше или равен цене (`price`).
  - **Зачем это нужно**:
    - Представьте, что цена книги отражает её качество, и вы хотите найти все книги, где рейтинг соответствует или превышает цену. Этот запрос поможет вам найти такие книги.
  - **Как это работает**:
    - `F('price')` позволяет получить текущее значение поля `price` для каждой записи и сравнить его с `rating` для той же записи. Это делается прямо в базе данных, без необходимости загружать данные в Python и обрабатывать их вручную.
    - **Резюме**: Код используется для анализа данных на основе сравнения двух полей внутри одной и той же записи.


# Дополнительные возможности `Q()` и простое объяснение `F()`

## 1. Операнды для `Q()`

- **AND**: `Q(condition1) & Q(condition2)`
  - Оператор `&` используется для соединения условий с логическим оператором "И" (AND).
  - **Пример**: 
    ```python
    books = Book.objects.filter(Q(author__name='John Doe') & Q(rating__gt=4))
    ```
    - Выбирает книги, написанные автором "John Doe" и с рейтингом выше 4.

- **OR**: `Q(condition1) | Q(condition2)`
  - Оператор `|` используется для соединения условий с логическим оператором "ИЛИ" (OR).
  - **Пример**: 
    ```python
    books = Book.objects.filter(Q(author__name='John Doe') | Q(rating__gt=4))
    ```
    - Выбирает книги, написанные автором "John Doe" или с рейтингом выше 4.

- **NOT**: `~Q(condition)`
  - Оператор `~` используется для инверсии условия, т.е. отрицания (NOT).
  - **Пример**: 
    ```python
    books = Book.objects.filter(~Q(author__name='John Doe'))
    ```
    - Выбирает все книги, которые не были написаны автором "John Doe".

## 2. Объяснение работы `F()` простыми словами

- **Как работает `F()`**:
  - `F()` позволяет вам **сравнивать или изменять значения полей в базе данных без загрузки данных в память Python**. Например, если у вас есть поле `price`, вы можете увеличить его значение на 10%, не загружая и изменяя каждую запись вручную.

- **Пример простого использования `F()`**:
  - **Задача**: Вы хотите увеличить цену всех книг на 10%.
  - **Код**:
    ```python
    Book.objects.update(price=F('price') * 1.1)
    ```
    - Здесь `F('price')` берет текущее значение поля `price` для каждой книги, умножает его на 1.1 и обновляет поле `price` в базе данных.

- **Понятное объяснение**:
  - Представьте, что `F()` — это как калькулятор, встроенный прямо в базу данных. Он позволяет вам напрямую выполнять операции с данными, не получая их сначала в программу. Это экономит время и ресурсы, особенно если данных много.
