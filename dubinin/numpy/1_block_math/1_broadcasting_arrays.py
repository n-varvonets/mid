import numpy as np

arr_1 = np.arange(6).reshape(3, 2)
arr_2 = np.arange(10, 16).reshape(3, 2)

print(arr_1)
print(arr_2)
# [[0 1]
#  [2 3]
#  [4 5]]

# [[10 11]
#  [12 13]
#  [14 15]]

###################
###### math #######
###################

# 1.1. Simple math - add
print(arr_1 + 5)  # к каждому елемнту массива добавится заданное число
# [[ 5  6]
#  [ 7  8]
#  [ 9 10]]

# 1.2. Simple math - умножение/деление/возведение в степеь и другие math operations
print(arr_1 * 5)  # к каждому елемнту массива умножениться заданное число
# [[ 0  5]
#  [10 15]
#  [20 25]]

# 2.1. math с массивами ОДИНАКОВОГО РАЗМЕРА
print(f"arr_1 + arr_2 = \n{arr_1 + arr_2}")
# arr_1 + arr_2 =
# [[10 12]
#  [14 16]
#  [18 20]]

########################################################
###### math операции с массивами РАЗНОГО размера #######
########################################################
# математические операци можно проводить ТОЛЬКО с согласованными масивами
# Согласованные массива - имеющие одинаковый размер
#        ок           |      не ок
# (3, 4)   (2, 5, 4)  |   (3, 4)       (3, 4)
# (3, 4)   (2, 5, 4)  |   (4, 3)       (3, 4, 2)


# 3.1. SHOW ERRORS
arr_1 = np.random.rand(3, 4)  # размер (3, 4)
arr_2 = np.random.rand(2, 5, 4)  # размер (2, 5, 4)

# Трансляция: arr_1 будет расширен для совместимости с arr_2
try:
    result_ok = arr_1 + arr_2
    print("Согласованные массивы:\n", result_ok)
except ValueError as e:
    print(f"Ошибка для согласованных массивов: {e}")

# Несогласованные массивы (размеры не согласованы, трансляция невозможна):
arr_3 = np.random.rand(3, 4)  # размер (3, 4)
arr_4 = np.random.rand(4, 3)  # размер (4, 3)
arr_5 = np.random.rand(3, 4, 2)  # размер (3, 4, 2)

# Ошибка трансляции для arr_3 и arr_4 (разные оси)
try:
    result_not_ok_1 = arr_3 + arr_4
except ValueError as e:
    print(f"Ошибка для arr_3 + arr_4: {e}")

# Ошибка трансляции для arr_3 и arr_5 (размерности не согласованы)
try:
    result_not_ok_2 = arr_3 + arr_5
except ValueError as e:
    print(f"Ошибка для arr_3 + arr_5: {e}")

# 3.2. SOLVE ERRORS by broadcasting
# - 1 Правило: если массивы имет разное кол-во осей, то к массиво с меньшим количеством добавляются новые, что б размерности совпали.
# -- Автоматически добавленние осей происходит слева, но самому массиву можно добавить любые оси.
# - 2 Правило: в массивах на соотвутсвующих осях должно быть
# --- или одинаковое кол-во елементов
# --- или один елемент в одном из массивов

arr = np.array([3])
print(arr.shape)
print(arr_1.shape)
# (1,)
# (3, 4)

print(arr_1 * arr)
# [[2.0026591  2.4432438  1.78725141 0.73322268]
#  [0.12002103 0.13596127 0.21917683 2.42415158]
#  [0.45155251 1.09205382 0.43165555 2.83137385]]

##############################
###### реальная задача #######
##############################
# 1.1. на исходных данных
arr = np.arange(5 * 3 * 2).reshape([5, 3, 2])
# 1.2. были вычисленны поправки, которые нужно отнять от каждого набора данных
arr_1 = np.arange(5, 10)

# 2.1. Определим как изменить массив, что б  из певрого вычесить второй
print(arr.shape)  # (5, 3, 2)
print(arr_1)  # [5 6 7 8 9]
print(arr_1.shape)  # (5,)

# 2.2. Изменяем массив
arr_1.shape = (5, 1, 1)
print(arr_1)
# [[[5]]
#
#  [[6]]
#
#  [[7]]
#
#  [[8]]
#
#  [[9]]]

# 2.3. Теперь без ошибок из одного массива можно вычесть второй
print(f"arr - arr_1 = \n{arr - arr_1}")
# arr - arr_1 =
# [[[-5 -4]
#   [-3 -2]
#   [-1  0]]
#
#  [[ 0  1]
#   [ 2  3]
#   [ 4  5]]
#
#  [[ 5  6]
#   [ 7  8]
#   [ 9 10]]
#
#  [[10 11]
#   [12 13]
#   [14 15]]
#
#  [[15 16]
#   [17 18]
#   [19 20]]]
