import numpy as np

# Исходный трехстрочный массив
# <u>Главное правило!</u> - кол-во елементов в новом елементе, должны равняться кол-ву елементов в исходном.
np_array = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])
print("Исходный массив:")
print(np_array)
# Вывод:
# [[1 2 3 4]
#  [2 3 4 5]
#  [3 4 5 6]]

# Изменение формы массива на одномерный
np_array.shape = 12
print("Одномерный массив:")
print(np_array)  # Все элементы теперь в одной строке
# Вывод:
# [1 2 3 4 2 3 4 5 3 4 5 6]

# Изменение формы на 2 строки и 6 столбцов
np_array.shape = (2, 6)
print("Массив 2x6:")
print(np_array)
# Вывод:
# [[1 2 3 4 2 3]
#  [4 5 3 4 5 6]]

# Изменение формы на трехмерный массив
np_array.shape = (2, 2, 3)
print("Трехмерный массив 2x2x3:")
print(np_array)
# Вывод:
# [[[1 2 3]
#   [4 2 3]]
#
#  [[4 5 3]
#   [4 5 6]]]

# Автоматическое вычисление количества строк, 12 столбцов
np_array.shape = (-1, 12)
print("Авто-строки, 12 столбцов:")
print(np_array)
# Вывод:
# [[1 2 3 4 2 3 4 5 3 4 5 6]]

# Автоматическое вычисление количества столбцов, 4 строки
np_array.shape = (4, -1)
print("4 строки, авто-столбцы:")
print(np_array)
# Вывод:
# [[1 2 3]
#  [4 2 3]
#  [4 5 3]
#  [4 5 6]]

#########

print("4x3 and 3x4 и как елементы распределяются\n"
      "єто не траспонация(строки->столбцы), а просто почередное вставка елементов вмассивы по очереди")
np_array.shape = (4, 3)
print(np_array)
np_array.shape = (3, 4)
print(np_array)
# [[1 2 3]
#  [4 2 3]
#  [4 5 3]
#  [4 5 6]]
# [[1 2 3 4]
#  [2 3 4 5]
#  [3 4 5 6]]

#####################
###### RESHAPE ######
#####################

# Использование reshape для создания нового массива
reshaped_array = np_array.reshape((2, 2, 3))
print("Результат применения reshape:")
print(reshaped_array)
# Вывод:
# [[[1 2 3]
#   [4 2 3]]
#  [[4 5 3]
#   [4 5 6]]]

# Оригинальный массив остается неизменным
print("Исходный массив после применения reshape:")
print(np_array)
# Вывод:
# [[1 2 3 4]
#  [2 3 4 5]
#  [3 4 5 6]]

# Изменение элементов в reshaped_array также изменяет элементы в np_array, так как это представление того же массива
reshaped_array[0] = 100
# изменения косунтся толькл первій елемент - [[1 2 3], [4 2 3], 2ой елемент, ..., n-елемент]
# [[[1 2 3]
#   [4 2 3]]
#  [[4 5 3]
#   [4 5 6]]]
print("Измененный reshape массив:")
print(reshaped_array)
# Измененный reshape массив:
# [[[100 100 100]
#   [100 100 100]]
#
#  [[  4   5   3]
#   [  4   5   6]]]


print("Исходный массив после изменения reshape:")
print(np_array)
# Исходный массив после изменения reshape:
# [[100 100 100 100]
#  [100 100   4   5]
#  [  3   4   5   6]]


#####################
###### RESIZE #######  не следует ГЛАВНЕОМУ правилу - кол-во елементов в новом елементе, должны равняться кол-ву елементов в исходном.
##################### - зачем? если добавить новые елементы в массив, то проще СНАЧАЛА расширить массив, а потом в нули добавлять по елементу - ЭТО СИЛЬНО УСКОРИТ ПРОЦЕСС

# Использование метода .resize() для изменения массива на форму (2, 6)
np_array.resize((2, 6))
print("Измененный массив после .resize((2, 6)):")
print(np_array)
# Вывод:
# [[1 2 3 4 2 3]
#  [4 5 3 4 5 6]]

# Попытка изменить размер массива с использованием отрицательного значения приводит к ошибке
# np_array.resize((-1, 2))  # ValueError: negative dimensions are not allowed

# Пример с изменением формы на (4, 2) с использованием resize() без refcheck
np_array.resize((4, 2), refcheck=False)
print("Измененный массив после с 8ю елемнетами, вместо исходного 12ти .resize((4, 3), refcheck=False):")
print(np_array)
# Вывод:
# [[100 100]
#  [100 100]
#  [100 100]
#  [  4   5]]

# добавление новых елементов
np_array.resize((10, 2), refcheck=False)
print("Измененный массив после с 10ю елемнетами, вместо исходного 12ти .resize((4, 3), refcheck=False):")
print(np_array)
# Вывод:
# [[100 100]
#  [100 100]
#  [100 100]
#  [  4   5]
#  [  0   0]
#  [  0   0]
#  [  0   0]
#  [  0   0]
#  [  0   0]
#  [  0   0]]


#########################
###### RAVEL/VIEW #######
#########################

# Создаем исходный двумерный массив
np_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Использование метода .ravel() для создания одномерного представления массива
flat_array = np_array.ravel()
print('Плоское представление массива:', flat_array)
# Вывод: [1 2 3 4 5 6 7 8 9]

# Использование метода .view() для создания нового представления массива
new_copied_view = np_array.view()
print('Исходное представление массива:\n', np_array)
# Вывод: [[1 2 3] [4 5 6] [7 8 9]]
print('скопированное представление массива:\n', new_copied_view)
# Вывод: [[1 2 3] [4 5 6] [7 8 9]]

# Изменение элемента в новом представлении
new_copied_view[0, 0] = 999
print('Измененное значений массива:\n', new_copied_view)
# Вывод: [[999 2 3] [4 5 6] [7 8 9]]
print('Исходный массив после изменения значений через view:\n', np_array)
# Вывод: [[999 2 3] [4 5 6] [7 8 9]]
# !!! ЗНАЧЕНИЯ МЕНЯЮТСЯ везде(в начальном, что в конечном), НО не формы представления


# Изменение формы представления. Т.Е. значения меняются везде одинаково(ИСПОЛЬЗУЮТ ОДНИ И ТЕ ЖЕ ДАННыЕ),  а форма для каждого своя ОСТАЕТСЯ
np_array.shape = (9)
print(' изменения форма массива:\n', np_array)
# Вывод: [[999 2 3] [4 5 6] [7 8 9]]
print('НЕИЗМЕНЕННАЯ форма массива через view:\n', new_copied_view)
# [[999   2   3]
#  [  4   5   6]
#  [  7   8   9]]

###################
###### copy #######
###################
np_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Создание копии массива с использованием .copy()
copied_array = np_array.copy()
print("Исходный массив:\n", np_array)
print("Копированный массив:\n", copied_array)
# Исходный массив:
#  [[1 2 3]
#  [4 5 6]
#  [7 8 9]]
# Копированный массив:
#  [[1 2 3]
#  [4 5 6]
#  [7 8 9]]

# Изменение элемента в копии
copied_array[0, 0] = 999
print("Измененный копированный массив:\n", copied_array)
print("Исходный массив после изменения копированного массива:\n", np_array)
#  Измененный копированный массив:
#  [[999   2   3]
#  [  4   5   6]
#  [  7   8   9]]
# Исходный массив после изменения копированного массива:
#  [[1 2 3]
#  [4 5 6]
#  [7 8 9]]
