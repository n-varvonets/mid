# Архитектура и использование паттернов проектирования

## История паттернов

Паттерны проектирования были не "придуманы", а "открыты". Это не оригинальные решения, а типовые подходы, которые повторяются при решении одинаковых проблем. Термин "GoF book" произошёл от названия книги «Design Patterns: Elements of Reusable Object-Oriented Software», написанной "бандой четырёх" — Эрихом Гаммой, Ричардом Хелмом, Ральфом Джонсоном и Джоном Влиссидесом.

## Основная идея применения паттернов

Надо не искать возможность куда паттерны впихнуть.. потому что патерн решает конкретную проблему, если этой проблемы нет, то ее решать не нада

- **Создание паттернов**: Не паттерн решает проблему, а потребность в решении конкретной задачи приводит к использованию подходящего паттерна.

- **Пример вопроса при проектировании**:
  1. `Нужно ли создавать объекты динамически?` — Открываем порождающие паттерны.
  2. `Нужно ли менять поведение в зависимости от ситуации?` — Рассматриваем поведенческие паттерны.
  3. `Нужно ли структурировать или связывать разрозненные компоненты?` — Обращаемся к структурным паттернам.

## Классификация паттернов (по книге GoF)

Паттерны делятся на три группы: порождающие, структурные и поведенческие. Чтобы правильно выбрать паттерн, нужно декомпозировать задачу по этим критериям:


# Основные паттерны проектирования с простыми примерами

## 1. Порождающие паттерны

Порождающие паттерны помогают создавать объекты и управлять их созданием, избегая жёсткой привязки к конкретным классам. Это полезно, когда нужно гибко контролировать процесс создания объектов.

### Пример: Фабрика (Factory)
Паттерн **Фабрика** используется, когда нужно создавать разные типы объектов в зависимости от условий, но при этом не нужно явно указывать, какой именно объект создавать.

**Пример:**
```python
class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

class AnimalFactory:
    @staticmethod
    def get_animal(animal_type):
        if animal_type == "dog":
            return Dog()
        elif animal_type == "cat":
            return Cat()
        return None

# Использование фабрики
factory = AnimalFactory()
animal = factory.get_animal("dog")
print(animal.speak())  # Выведет: Woof!
```

### Когда использовать:
- Когда у вас есть несколько подклассов, и вы хотите динамически выбирать, какой из них создать.
- Пример: приложение, которое может создавать разные виды животных в зависимости от пользовательского ввода.

## 2. Структурные паттерны

Структурные паттерны помогают организовать объекты и классы для работы вместе, обеспечивая гибкость и уменьшение дублирования кода.

### Пример: Адаптер (Adapter)
Паттерн **Адаптер** позволяет объектам с несовместимыми интерфейсами работать вместе. Он "оборачивает" один объект так, чтобы он соответствовал интерфейсу другого.

**Пример:**
```python
class OldPrinter:
    def print_old_format(self, text):
        print(f"Old Printer: {text}")

class NewPrinter:
    def print_new_format(self, text):
        print(f"New Printer: *** {text} ***")

# Адаптер, который позволяет использовать новый принтер с интерфейсом старого
class PrinterAdapter:
    def __init__(self, new_printer):
        self.new_printer = new_printer

    def print_old_format(self, text):
        self.new_printer.print_new_format(text)

# Использование
old_printer = OldPrinter()
new_printer = PrinterAdapter(NewPrinter())

old_printer.print_old_format("Hello")  # Old Printer: Hello
new_printer.print_old_format("Hello")  # New Printer: *** Hello ***
```

### Когда использовать:
- Когда у вас есть два несовместимых класса, и вам нужно заставить их работать вместе без изменения их кода.

## 3. Поведенческие паттерны

Поведенческие паттерны определяют, как объекты взаимодействуют друг с другом и как реагируют на изменения в системе.

### Пример: Наблюдатель (Observer)
Паттерн **Наблюдатель** используется, когда один объект (издатель) изменяет своё состояние, и другие объекты (подписчики) должны быть уведомлены об этих изменениях.

**Пример:**
```python
class Publisher:
    def __init__(self):
        self.subscribers = []

    def subscribe(self, subscriber):
        self.subscribers.append(subscriber)

    def notify(self, message):
        for subscriber in self.subscribers:
            subscriber.update(message)

class Subscriber:
    def update(self, message):
        print(f"Received message: {message}")

# Создание издателя и подписчиков
publisher = Publisher()
subscriber1 = Subscriber()
subscriber2 = Subscriber()

# Подписчики подписываются на издателя
publisher.subscribe(subscriber1)
publisher.subscribe(subscriber2)

# Издатель уведомляет всех подписчиков
publisher.notify("New update available!")
```

### Когда использовать:
- Когда один объект должен уведомлять другие объекты о своём изменении, но при этом не знает, кто эти объекты.
- Пример: система подписки на события, где приложение сообщает пользователям о новых событиях.

----
## Проблемы неоправданного использования паттернов

- **Неоправданное применение**: Использование паттернов без реальной необходимости приводит к усложнению системы. Как говорится, если у тебя в руках молоток, все предметы вокруг начинают напоминать гвозди. Нужно оценивать каждую задачу и выбирать паттерны только там, где это оправдано.

## Декомпозиция задачи

При проектировании системы необходимо учитывать три ключевых аспекта:
1. **Декомпозиция** — Разбиение задачи на более мелкие подзадачи.
2. **Именование** — Правильное именование переменных и методов. Если имя сложно подобрать, значит объект или компонент выделен неправильно.
3. **Композиция** — Объединение компонентов в единую систему. На этом этапе паттерны играют ключевую роль.


## Основные паттерны (кратко)

1. **Фабрика** — Позволяет создавать объекты без указания точного класса создаваемого объекта.
2. **Наблюдатель** — Позволяет объектам отслеживать события в другом объекте и реагировать на них.
3. **Адаптер** — Преобразует интерфейс одного класса в интерфейс, ожидаемый другим классом.
4. **Одиночка (Singleton)** — Гарантирует, что у класса будет только один экземпляр, и предоставляет к нему глобальную точку доступа.
5. **Команда** — Инкапсулирует запрос как объект, позволяя параметризовать клиентов с различными запросами, очередями запросов и операциями отката.
6. **Стратегия** — Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.

