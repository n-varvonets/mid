1. по какой причине нью может не первым?
2. идемпотентность это методов
3. что в jwt токенах и хранятся ли они в бд. джанго?
4. как в список поместить множество других списков в список. через вор и екстенд? а как можно улучшить?
5. по какой причине не заходит в post_save джанго?
6.в чем разница между тапла и сета? Раскажи глубже про сет
7.как реализуются контекстный менеджер. можно ли реализовать декоратор через клас? и в чем разница тогда класово декратора от класового котестного менеджера? что-то похожу на трай ексепт финали?
8. чем отличается балк апдейт от обычного апдейта? как ефективно обновить 2 млн записей в таблице,
что в каждом поле изменить уникальнкю информацию(значение) которая расчитывается отедьлно для кажой записи. В джанго есть values()  и  еще что-то.. в чем их разница
9. на класс можно навешать декратор? пример с джанго


10. что такое кодировка?
таблица соответсвий символ в байты/машынный код, поэтому ютф-8 такая популярная.
Поэтому в текстовом файле неважно гле мсиволы ноходяться,  потому что они(символы) будут соответсвовать одному и тому же байтам.
В отличии от исполняемого файла, где структура это важно


11. почему после десерилизации удобнее работать с обьектом, а не словарем, ведь приходит к нам джсон.. т.е. почему к обьекту мы обращаемся через точку, а не ['']?
на дает десериализацию пришедшего json(байты, то что мы в текст переводим, мы доставем кодировку и кодируем эти символы.. просто текст)
и десириализация нужна для валидации данных, т.е. соответсвия контракта( соотвуетсвующий инпут от клиента). и вот валиадцаия этих полей
лучше делать при помощи обьектов пайтона, инкапслуруя в них логику валдиации через ооп (пайдентик бибилотека из под капота джанго)


12. как работает конкуретность в пайтоне,какие виды(вытесняющая и т.п.)


13. почему пайтон медленный


14. как построить архитектуру под эти патерны? (Архитектура и использование паттернов проектирования)


15. почему нельзя прокидывамуть мутабильные обьекты в функцию?
- потому что тогда аргумент будет хранить указатель на обьект и при последующих вызовов функции в других местах аргумент НЕ БУДЕТ ЗАНОВО ИНЦИАЛИЗИРОВАН
- можно через Ноне прокнуть какой динамический аргумент + тайпхинтинг


16. генераторы и сопрограмы
- генераторы - функция с yeild. при каждом новом вызове функции next() код генератора исполняется с места где в прошлый раз вернул значение.
-- в этом и отличие от return(который убивает весь стек вызова функции, а yield делает так что стек сохраняется)
-- в генераторе может быть return что б завершить стек вызов
- сопрограми
-- корутины, они асинхронные функцие, КОТОРЫЕ ПОСТРОЕНЫ на генераторах
-- т.е. генератор который принимает данные через send() называется корутины генераторов, НО НЕ асинхронной функцией


17. паттерн цепочка обьязаностей и генератор send().
(Телеграм учтоняющие вопросы по одному собирает инфу о клиенте - т.е. на каждой интерации с тобой задает тебе вопросы)
- цеопчка задавания вопросов - явный патерн цепочка обьязаностей


18.утиная типизация
- Если это выглядит как утка, плавает как утка и крякает как утка, то это утка
- В Python нет необходимости явно указывать, что два класса должны следовать какому-то интерфейсу.
-- Если объект имеет такой метод, он может быть передан в функцию. Если объект не имеет нужного метода, программа выдаст ошибку только во время выполнения, а не на этапе компиляции.
-- просто. если обьект реализует метод(интерфейс), то он считается данным типом (уткой)


19. в чем разница между тайп и object в метаклассах?
- type — (создаль классов) создает классы, потому что класс ЯВЛЯЕТСЯ ЕКЗЕМЛЯРОМ(инстансоv) класса type
- object — (родитель классов) класс от которого любой созданный класс наследует какие-то аттрибуты
```
class MyClass:
    pass
my_instance = MyClass()
print(isinstance(my_instance, object))  # Выведет: True
print(isinstance(my_instance, type))  # Выведет: False
print(type(MyClass))  # Выведет: <class 'type'>  -  В Python классы создаются с помощью метакласса type. Это означает, что сам класс MyClass является экземпляром метакласса type
print(type(type))  # Выведет: <class 'type'>
```
схема:
    object
      └── type
          ├── MyClass
          │   └── my_instance
          └── type


20. GIL. Что такое состояние гонки?
— это ошибка в многопоточном или многопроцессном программировании, которая возникает, когда
--- несколько потоков или процессов одновременно пытаются изменить одни и те же данные,
--- и порядок выполнения этих потоков или процессов не определён.
- поэтому GIL и был введен, что б защищать внутренние структуры данных И ИЗБЕЖАТЬ СОСТОЯНИЕ ГОНКИ


21. Что делали если б не было веб-фрейморвков?
Пришлось бы разрабатывать
- Обработка HTTP-запросов:
- Маршрутизация (Routing):
- Поддержка сессий и авторизации:
- Безопасность: (от XSS, CSRF, SQL-инъекций и других атак самостоятельн)
- Обработка баз данных


22. что такое чистая архитектура?
проблема разрабов долгосрочніх проектах, єто
- рост кодовой базы
- контроль над этим всем
Чистая архитектура в долгосроке дает УДОБНОЕ СОПРОВОЖДЕНИЕ проекта. - разделяет приложение на независимые слои.
Основная идея — бизнес-логика приложения не должна зависеть от внешних систем (баз данных, фреймворков, UI).
Пример: луковая архитектура - архитектура из слоёв:
- ядро: бизесс логика
- 1ый слой: сервисы aws и т.д.
- 2ой слой бд,броекры, внешние API
- поседний слой - вебфреймоврки(http, routing, security)


23. про связность(Cohesion) и связанность(Coupling)
Идеальный баланс:
Высокая связность (внутри модуля) + низкая связанность (между модулями) — это идеал в проектировании.
Это означает, что каждый модуль делает одну задачу хорошо (связность), и изменение одного модуля минимально влияет на другие (связанность).


24. микросервисы, монолит, распределнный монолит и принцип душения
Микросервисы — это когда приложение делится на небольшие, независимые сервисы,
каждый из которых отвечает за одну конкретную задачу или бизнес-функцию.
Преимущества микросервисов:
    - Масштабируемость: Можно масштабировать только те сервисы, которые требуют дополнительных ресурсов, не затрагивая другие части системы.
    - Независимая разработка: Команды могут работать над разными микросервисами независимо друг от друга, что ускоряет разработку.
    - Устойчивость к сбоям: Если один микросервис выходит из строя, это не обязательно влияет на работу всей системы.
    - Гибкость в технологиях: Для каждого микросервиса можно выбрать наиболее подходящую технологию и язык программирования.
    - БД: используют разные БД, а взаимодействуют по ЕНДПОНИТАМ
    - git: каждый сервис хранится отдельно по репозиториям
Недостатки микросервисов:
    - Сложность управления: Большое количество микросервисов может усложнить управление системой, мониторинг и отладку.
    - Межсервисная коммуникация: Требуется дополнительная инфраструктура для обеспечения надежного взаимодействия между сервисами.

Ну монолит мы тоже масштабировать.. просто запустить две реплики монолита, которую смотрт в одну базу, НО в этом то и проблема

Если один сервис требует компоненты, который обрабатывает другой, то нужно по ЕНДПОИНТАМ постучаться другого(НО НЕ ОБРАЩАТЬСЯ к одной и той же БД),
потому что огда один микросервис лезит в БД другого микросервиса, то ЭТО В ДОЛГОСРОКЕ ПЛОХО.. как раз про связаность.

Заключение
    - Микросервисы лучше подходят для сложных и масштабируемых систем, где требуется гибкость и независимость компонентов.
    - Распределённый монолит сохраняет зависимость компонентов и данных, что ограничивает масштабируемость.
    - Принцип душения помогает постепенно перейти от монолита к микросервисам, минимизируя риски.


25. Как взаимодействуют микросервисы? определнный интерфейс. почему лучше использовать (Message Queues) и консьюмеров вместо http запросов и что такое  API Gateway?

26.а) Какие проблемы решает брокер?
Например, Есть веб сервис, который принима
ет задания ОТ КЛИЕНТА, єтот сервис пушит задания в брокер консьмера, а другой сервис читает задание консьюмера и выполняет его.
Таким образом нужно
- принять сообщение
- преоброзовать егов таску
- сериализовать в байты
- отправить в брокер у нужному консьюмеру
Решает задачи:
- Брокер позволяет положить таску в очередь и по мере постпления их обробатывать, тем самым решая проблему загруженности.
--Т.Е. АСИНХРОННО решает проблемы, в отличии от http запросов,которій решает задачи СИНХРОННО
- так жен 2ой сервис(который выполняет задачу)  - упадет(таймаут и т.д.), то сообщение/таска пользователя НЕ ПОТЕРЯЕТСЯ
- это dependancy inversion для архитектуры -  микросервеси ненапрямую взаимдействуют друг с другом, а через некую абстракцию(брокера), при том что сервисы не подозревают о существовании друг друга
26.б) Какие проблемы он приносит?
- это отдельный сервис и нужен под него сервер, нужно его поддерживать


27. кафка это и брокер и консьюмер?  каким образом консьюмер понимает что надо забрать сообщение
- Консьюмеры — это не программные продукты, а конкретные микросервисы или программы, которые ты разрабатываешь, чтобы забирать сообщения из брокеров.
- Консьюмеры подписываются на очередь в брокере сообщений. После подписки:
    - Брокер сообщений (например, RabbitMQ или Kafka) кладёт сообщение в очередь.
    - Консьюмер постоянно проверяет очередь или получает сообщение, как только оно появляется.
    - Консьюмер забирает сообщение и выполняет задачу (например, обрабатывает заказ или отправляет уведомление).


28. в чем разница между виртуальной машиной и контейнером?где запустить наше приложение в виртальной машине в облаке или в контейнере в облаке?
- Контейнер - изолция на уровне ОС. ядро ОС(линкус напрмер - Общая ОС с хостом) предоставляет МЕХАНИЗМІ ИЗОЛЦИИ ПРОЦЕССОВ(application layer) от других проессов - легкая
- Виртуализцаия - Каждая VM имеет свою ОС, т.е. полная изоляция, независимая ОС - медленная. Т.е. ОС запущенная в VM думает,
что она имеет прямой доступ к железу, а на самом деле НЕТ. Между неими прослойка, которая создает ГИПЕРВИЗОР в хотчевой ОС
Проблема: - у докера есть демон
- Клиент и сервер: Docker работает по принципу "клиент-сервер". Клиент (команда Docker) отправляет запросы демону,
который обрабатывает их.(Т.Е. отправляет запрос ядро, типо "ей ядро, запусти мне процесс такой-то или оставнови")
- Фоновая работа: демон работает постоянно, ожидая команд (например, запуск или остановка контейнера).
- Если демон Docker отключается или выходит из строя, управление контейнерами прекращается, и все контейнеры могут остановиться. - ЕГО НУЖНО ПОДДЕРЖИВАТЬ И СЛЕДИТЬ ЗА НИМ


29. в чем разница между докером и докер компоуз?
- Docker: Управляет отдельными контейнерами (например, запуск одного веб-сервера).
- Docker Compose: Позволяет запускать несколько связанных контейнеров одновременно (например, веб-сервер, база данных и кэш вместе).

30. что такое ACID в бд..
- A	Atomicity	Атомарность: транзакция либо завершается полностью, либо не происходит ничего.
- C	Consistency	Согласованность: данные в базе данных всегда находятся в согласованном состоянии после транзакции.
Для достижения согласованности применяются триггеры, ограничения и бизнес-логика (например, проверка на минимальный баланс)
- I	Isolation	Изолированность: параллельные транзакции не влияют друг на друга.
- D	Durability	Надёжность: после завершения транзакции её результаты сохраняются даже в случае сбоя системы.
30.а.  Если в двух вкладках нажали "Оплатить" одновременно — произойдёт ли двойная оплата?
- Одним из самых эффективных решений является введение идемпотентности транзакций
    - Каждой транзакции присваивается уникальный идентификатор (например, номер заказа, номер транзакции).
    - Когда пользователь отправляет запрос на оплату, система сохраняет этот идентификатор и проверяет его перед выполнением транзакции.
    - Если другой запрос с тем же идентификатором приходит снова (даже если его отправили через другую вкладку или с задержкой),
      система понимает, что это повторный запрос, и просто игнорирует его, так как транзакция уже была выполнена.
- Использование блокировок на уровне базы данных (Isolation и Locking)
    - Когда первый запрос на оплату приходит, система блокирует запись в базе данных, которая относится к счёту клиента.
    - Пока транзакция первого запроса не завершится (успешно или с ошибкой), второй запрос не сможет изменить те же данные.
    - После завершения первой транзакции блокировка снимается, и следующий запрос может быть обработан.   -
Пример реализации: КОМБИНАЦИЯ методов и система будет работать:
    - Запросы отправляются одновременно, все с идентификатором транзакции TX12345.
    - Первый запрос проходит через проверку и блокирует запись о балансе пользователя.
    - Пока первый запрос обрабатывается, все другие запросы с тем же идентификатором либо блокируются, либо отклоняются как повторные.
    - После завершения первой транзакции другие запросы проверяются, но видят, что идентификатор транзакции TX12345 уже обработан, и не выполняются.
30.б. Серилизация транзакций — это один из методов блокировки, при котором транзакции выполняются последовательно,
как бы "по очереди". Это гарантирует, что каждая транзакция выполняется в изолированном состоянии,
и данные не изменяются до завершения текущей транзакции. (в отличии от ГРЯЗНОГО ЧТЕНИЯ, что не начинать работать с незавершенной транзакцией)


31. NoSQL, JSON и BASE
- В реляционных базах данных (SQL) данные хранятся в таблицах с фиксированной схемой.
В NoSQL данных нет строгой схемы, и вместо таблиц используются коллекции или индексы, где каждый документ может иметь разную структуру.
- Поэтому Простота работы с JSON: NoSQL базы предоставляют более удобные механизмы для работы с JSON,
такие как встроенные инструменты для поиска и обновления JSON-документов.
- в BASE, S - Soft state	Состояние системы может изменяться со временем, даже без запросов,
где ВА - Данные всегда доступны, но могут быть временно несогласованными.(не иметь конкретизации аттрибутов документов или как?)




