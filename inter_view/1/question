1. по какой причине нью может не первым?
2. идемпотентность это методов
3. что в jwt токенах и хранятся ли они в бд. джанго?
4. как в список поместить множество других списков в список. через вор и екстенд? а как можно улучшить?
5. по какой причине не заходит в post_save джанго?
6.в чем разница между тапла и сета? Раскажи глубже про сет
7.как реализуются контекстный менеджер. можно ли реализовать декоратор через клас? и в чем разница тогда класово декратора от класового котестного менеджера? что-то похожу на трай ексепт финали?
8. чем отличается балк апдейт от обычного апдейта? как ефективно обновить 2 млн записей в таблице,
что в каждом поле изменить уникальнкю информацию(значение) которая расчитывается отедьлно для кажой записи. В джанго есть values()  и  еще что-то.. в чем их разница
9. на класс можно навешать декратор? пример с джанго


10. что такое кодировка?
таблица соответсвий символ в байты/машынный код, поэтому ютф-8 такая популярная.
Поэтому в текстовом файле неважно гле мсиволы ноходяться,  потому что они(символы) будут соответсвовать одному и тому же байтам.
В отличии от исполняемого файла, где структура это важно


11. почему после десерилизации удобнее работать с обьектом, а не словарем, ведь приходит к нам джсон.. т.е. почему к обьекту мы обращаемся через точку, а не ['']?
на дает десериализацию пришедшего json(байты, то что мы в текст переводим, мы доставем кодировку и кодируем эти символы.. просто текст)
и десириализация нужна для валидации данных, т.е. соответсвия контракта( соотвуетсвующий инпут от клиента). и вот валиадцаия этих полей
лучше делать при помощи обьектов пайтона, инкапслуруя в них логику валдиации через ооп (пайдентик бибилотека из под капота джанго)


12. как работает конкуретность в пайтоне,какие виды(вытесняющая и т.п.)


13. почему пайтон медленный


14. как построить архитектуру под эти патерны? (Архитектура и использование паттернов проектирования)


15. почему нельзя прокидывамуть мутабильные обьекты в функцию?
- потому что тогда аргумент будет хранить указатель на обьект и при последующих вызовов функции в других местах аргумент НЕ БУДЕТ ЗАНОВО ИНЦИАЛИЗИРОВАН
- можно через Ноне прокнуть какой динамический аргумент + тайпхинтинг


16. генераторы и сопрограмы
- генераторы - функция с yeild. при каждом новом вызове функции next() код генератора исполняется с места где в прошлый раз вернул значение.
-- в этом и отличие от return(который убивает весь стек вызова функции, а yield делает так что стек сохраняется)
-- в генераторе может быть return что б завершить стек вызов
- сопрограми
-- корутины, они асинхронные функцие, КОТОРЫЕ ПОСТРОЕНЫ на генераторах
-- т.е. генератор который принимает данные через send() называется корутины генераторов, НО НЕ асинхронной функцией


17. паттерн цепочка обьязаностей и генератор send().
(Телеграм учтоняющие вопросы по одному собирает инфу о клиенте - т.е. на каждой интерации с тобой задает тебе вопросы)
- цеопчка задавания вопросов - явный патерн цепочка обьязаностей


18.утиная типизация
- Если это выглядит как утка, плавает как утка и крякает как утка, то это утка
- В Python нет необходимости явно указывать, что два класса должны следовать какому-то интерфейсу.
-- Если объект имеет такой метод, он может быть передан в функцию. Если объект не имеет нужного метода, программа выдаст ошибку только во время выполнения, а не на этапе компиляции.
-- просто. если обьект реализует метод(интерфейс), то он считается данным типом (уткой)


19. в чем разница между тайп и object в метаклассах?
- type — (создаль классов) создает классы, потому что класс ЯВЛЯЕТСЯ ЕКЗЕМЛЯРОМ(инстансоv) класса type
- object — (родитель классов) класс от которого любой созданный класс наследует какие-то аттрибуты
```
class MyClass:
    pass
my_instance = MyClass()
print(isinstance(my_instance, object))  # Выведет: True
print(isinstance(my_instance, type))  # Выведет: False
print(type(MyClass))  # Выведет: <class 'type'>  -  В Python классы создаются с помощью метакласса type. Это означает, что сам класс MyClass является экземпляром метакласса type
print(type(type))  # Выведет: <class 'type'>
```
схема:
    object
      └── type
          ├── MyClass
          │   └── my_instance
          └── type


20. GIL. Что такое состояние гонки?
— это ошибка в многопоточном или многопроцессном программировании, которая возникает, когда
--- несколько потоков или процессов одновременно пытаются изменить одни и те же данные,
--- и порядок выполнения этих потоков или процессов не определён.
- поэтому GIL и был введен, что б защищать внутренние структуры данных И ИЗБЕЖАТЬ СОСТОЯНИЕ ГОНКИ


21. Что делали если б не было веб-фрейморвков?
Пришлось бы разрабатывать
- Обработка HTTP-запросов:
- Маршрутизация (Routing):
- Поддержка сессий и авторизации**:
- Безопасность: (от XSS, CSRF, SQL-инъекций и других атак самостоятельн)
- Обработка баз данных:
