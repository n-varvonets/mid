# ACID в базах данных

**ACID** — это набор свойств, которые гарантируют надежность операций с базами данных, особенно в условиях транзакционной обработки. ACID — это аббревиатура, которая расшифровывается как:

| Аббревиатура | Расшифровка      | Описание                                                                                                 |
|--------------|------------------|----------------------------------------------------------------------------------------------------------|
| A            | **Atomicity**     | Атомарность: транзакция либо завершается полностью, либо не происходит ничего.                           |
| C            | **Consistency**   | Согласованность: данные в базе данных всегда находятся в согласованном состоянии после транзакции.       |
| I            | **Isolation**     | Изолированность: параллельные транзакции не влияют друг на друга.                                         |
| D            | **Durability**    | Надёжность: после завершения транзакции её результаты сохраняются даже в случае сбоя системы.            |

## Описание ACID

### 1. Atomicity (Атомарность)
Операции в транзакции выполняются как единое целое: либо все действия транзакции успешно завершаются, либо ничего не происходит. Если что-то пошло не так (например, ошибка в середине транзакции), все изменения отменяются (откат).

- **Пример**: При переводе денег с одного банковского счета на другой транзакция гарантирует, что либо сумма будет снята и зачислена на другой счёт, либо не будет никаких изменений вообще, если произошла ошибка.

### 2. Consistency (Согласованность)
После завершения транзакции данные в базе данных всегда будут находиться в согласованном состоянии. Это значит, что транзакция приводит базу в состояние, соответствующее правилам и ограничениям (например, уникальные ключи, целостность ссылок и т.д.).

- **Пример**: При добавлении нового заказа в систему транзакция гарантирует, что у клиента есть достаточно средств, и база данных остаётся в согласованном состоянии.
- Для достижения согласованности применяются триггеры, ограничения и бизнес-логика (например, проверка на минимальный баланс)
### 3. Isolation (Изолированность)
Изолированность означает, что параллельно выполняющиеся транзакции не влияют друг на друга. Каждая транзакция работает так, как будто она единственная в системе, а изменения других транзакций не видны до их завершения.

- **Пример**: Два пользователя могут одновременно делать заказы, но каждый из них будет видеть своё состояние системы, не влияя на другого.

### 4. Durability (Надёжность)
Надёжность гарантирует, что после подтверждения транзакции её результаты сохранятся даже в случае сбоя системы (например, отключение питания или сбой сервера).

- **Пример**: Если вы завершили транзакцию по покупке товара, система гарантирует, что данные о покупке не будут потеряны, даже если после этого произошёл сбой сервера.
- **Почему не нарушается атомарность:**
  - Атомарность действует на уровне транзакции — всё или ничего. Если транзакция началась, но не завершилась, система откатит все изменения.
  - Но как только транзакция успешно завершилась и система подтвердила изменения, эти данные записываются надёжно.
## Пример: Две вкладки одного аккаунта

Представьте, что у пользователя открыты две вкладки с одним и тем же аккаунтом, и в обеих вкладках он нажимает "Оплатить" одновременно. Как база данных решит этот конфликт:

1. **Атомарность (Atomicity)**: Каждая транзакция будет либо завершена успешно, либо откатится, если что-то пойдет не так. Если деньги будут списаны в одной вкладке, операция в другой вкладке не пройдёт, потому что средств может не хватить.
2. **Согласованность (Consistency)**: В результате каждой транзакции база данных останется в согласованном состоянии. Например, баланс пользователя не будет отрицательным, так как каждая операция будет проверять наличие достаточных средств.
3. **Изолированность (Isolation)**: Операции из двух вкладок не будут видны друг другу до завершения транзакций. Одна транзакция завершится успешно, а вторая может завершиться с ошибкой, если, например, денег на счёте не хватит.
4. **Надёжность (Durability)**: Результат успешной транзакции будет сохранён даже в случае сбоя системы после её завершения. Если один платёж был успешно выполнен, даже при отключении системы данные не потеряются.

Таким образом, благодаря ACID, база данных корректно обрабатывает конфликтные ситуации, когда несколько транзакций происходят одновременно.

---

# Проблема многократных транзакций и решения

### Ситуация: многократные запросы на оплату
Если у пользователя на счёте достаточно средств, чтобы совершить несколько одинаковых платежей одновременно (например, 100 одинаковых запросов "оплатить"), система должна использовать механизмы блокировки и изолированности, чтобы предотвратить ошибочные многократные списания. Это связано с реализацией **ACID**-свойств, особенно **Isolation** (Изолированность) и **Atomicity** (Атомарность).

### Как система может предотвратить повторные списания?

#### 1. Использование уникального идентификатора транзакции (идемпотентность)

**Идемпотентность** — это метод, при котором, если один и тот же запрос отправляется несколько раз, он будет выполнен только один раз.

**Как это работает:**
- Каждой транзакции присваивается уникальный идентификатор (например, номер заказа, номер транзакции).
- Когда пользователь отправляет запрос на оплату, система сохраняет этот идентификатор и проверяет его перед выполнением транзакции.
- Если другой запрос с тем же идентификатором приходит снова, система понимает, что это повторный запрос, и игнорирует его.

**Пример:**
1. Первый запрос отправляется с идентификатором **TX12345**.
2. Второй и последующие запросы тоже содержат тот же идентификатор **TX12345**.
3. Система проверяет, что операция с этим идентификатором уже выполнена, и отказывается выполнять её повторно.

#### 2. Использование блокировок на уровне базы данных (Isolation и Locking)

**Блокировка записи в базе данных** — это метод, который помогает предотвратить одновременную обработку одинаковых транзакций.

**Как это работает:**
- Когда первый запрос на оплату приходит, система блокирует запись в базе данных, которая относится к счёту клиента.
- Пока транзакция первого запроса не завершится, второй запрос не сможет изменить те же данные.
- После завершения первой транзакции блокировка снимается, и следующий запрос может быть обработан.

**Пример:**
1. Первый запрос блокирует запись о счёте пользователя и выполняет транзакцию.
2. Другие запросы, которые приходят в это время, не смогут обработаться, пока первый запрос не завершится.
3. Когда первый запрос завершён, другие запросы видят обновлённый баланс и могут быть отклонены, если средств уже недостаточно.

#### 3. Использование очередей сообщений (Message Queues)

Этот метод позволяет обрабатывать запросы последовательно, предотвращая одновременное изменение данных.

**Как это работает:**
- Каждый запрос на оплату ставится в очередь (например, с использованием RabbitMQ или Kafka).
- Система обрабатывает запросы один за другим, гарантируя, что каждый запрос проверяется и обрабатывается последовательно.

#### Блокировка как серилизация

**Серилизация транзакций** — это один из методов блокировки, при котором транзакции выполняются последовательно, как бы "по очереди". Это гарантирует, что каждая транзакция выполняется в изолированном состоянии, и данные не изменяются до завершения текущей транзакции.

**Пример:**
1. Первая транзакция блокирует доступ к ресурсу (например, баланс клиента).
2. Пока первая транзакция не завершится, другие запросы на изменение этого ресурса будут стоять в очереди.
3. Как только первая транзакция завершится, следующие транзакции могут быть обработаны.

### Комбинация методов

Системы часто используют комбинацию всех этих методов для обеспечения защиты от повторных запросов:
- Идемпотентность для предотвращения многократной обработки одного и того же запроса.
- Блокировки для защиты данных от параллельных изменений.
- Очереди сообщений для последовательной обработки запросов.

### Заключение:
Чтобы избежать повторной оплаты, система должна использовать методы защиты от повторных запросов, такие как идемпотентность, блокировки (серилизация транзакций) и очереди сообщений. Это помогает гарантировать, что даже при большом количестве одинаковых запросов транзакция будет выполнена только один раз.
