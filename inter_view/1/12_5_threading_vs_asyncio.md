
# Различия между `threading` и `asyncio`

## Заключение:

- **`Threading`** использует несколько потоков и подходит для задач, которые могут блокироваться на время выполнения операций.
- **`Asyncio`** использует один поток и работает по принципу кооперативной многозадачности, позволяя эффективно обрабатывать I/O-bound задачи без блокировки потоков.
- Оба метода эффективны для **I/O-bound задач**, но имеют разные подходы к управлению выполнением задач.



## 1. `Threading` (многопоточность)

- **Многопоточность (`threading`)** создаёт несколько потоков, каждый из которых может выполнять задачи параллельно. Однако в Python это не всегда эффективно для задач, нагружающих CPU, из-за существования **GIL (Global Interpreter Lock)**.
- В многопоточности каждый поток может быть **блокирующим**. Это означает, что если поток выполняет I/O или другие операции, он может заблокироваться, и при этом процессорное время может быть потрачено впустую.
- **Поток может заблокироваться** при ожидании ввода-вывода (например, сетевых запросов или чтения файлов), и до тех пор не выполняет никаких других задач.
- Многопоточность **эффективно работает с I/O-bound задачами**, но при этом каждый поток "тяжёлый" для системы, так как управляется операционной системой и требует переключения контекста.

### Пример использования `threading`:
```python
import threading
import time

def blocking_task():
    time.sleep(2)  # Блокирующая операция
    print("Task complete")

threads = []
for _ in range(5):
    t = threading.Thread(target=blocking_task)
    t.start()
    threads.append(t)

for t in threads:
    t.join()
```

### Основные характеристики `threading`:
- Несколько потоков работают параллельно.
- **Каждый поток может быть заблокирован** на время выполнения операции.
- Подходит для I/O-bound задач, но имеет **большую нагрузку** на операционную систему (требуется больше памяти и переключения контекста).

---

## 2. `Asyncio` (асинхронное программирование)

- **`Asyncio`** работает в одном потоке и использует **кооперативную многозадачность**. Это значит, что задачи не блокируют выполнение, а могут передавать управление друг другу в **определённых точках** (обычно там, где происходит ожидание ввода-вывода).
- В **асинхронности** задачи выполняются последовательно, но могут **передавать управление** (с помощью ключевого слова `await`), когда требуется дождаться завершения долгой операции, например сетевого запроса.
- Это позволяет **эффективно использовать один поток**, не блокируя выполнение других задач, и делает **асинхронное программирование более лёгким для системы** по сравнению с потоками, так как не требует сложного управления потоками.

### Пример использования `asyncio`:
```python
import asyncio

async def non_blocking_task():
    await asyncio.sleep(2)  # Асинхронная неблокирующая операция
    print("Task complete")

async def main():
    tasks = [non_blocking_task() for _ in range(5)]
    await asyncio.gather(*tasks)

asyncio.run(main())
```

### Основные характеристики `asyncio`:
- Работает в одном потоке.
- Задачи **не блокируют выполнение** других задач, так как используют `await` для передачи управления.
- Эффективно работает с I/O-bound задачами, без создания дополнительных потоков.
- Не требует переключения контекста между потоками, как в многопоточности.

