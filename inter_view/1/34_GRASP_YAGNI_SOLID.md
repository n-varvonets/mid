# GRASP, YAGNI и SOLID: В чем разница?


## 1. GRASP (General Responsibility Assignment Software Patterns)

**GRASP** — это аббревиатура, которая расшифровывается как "Шаблоны распределения ответственности в программном обеспечении" (General Responsibility Assignment Software Patterns). Это не сокращение, а набор из 9 шаблонов, которые помогают проектировщикам распределять ответственность между объектами в объектно-ориентированных системах. Каждый из этих шаблонов помогает решить определённые задачи проектирования.

## 1. Information Expert (Информационный эксперт)

### Задача:
Этот шаблон определяет, какой объект должен выполнять задачу. Обычно это тот объект, который содержит нужные для выполнения задачи данные.

### Пример:
Мы разрабатываем систему заказов. Объект `Order` знает, какие товары содержатся в заказе, а значит, он должен отвечать за вычисление общей стоимости заказа.

```python
class Item:
    def __init__(self, name, price):
        self.name = name
        self.price = price

class Order:
    def __init__(self, items):
        self.items = items

    # Information Expert: Order знает о товарах, поэтому он отвечает за вычисление общей стоимости.
    def calculate_total(self):
        return sum(item.price for item in self.items)

# Пример использования
items = [Item("Laptop", 1000), Item("Mouse", 50)]
order = Order(items)
print(order.calculate_total())  # Output: 1050
```

### Как было бы неправильно:
Если бы мы вынесли вычисление суммы заказа в отдельный объект, который не имеет прямого доступа к товарам, пришлось бы передавать информацию туда-сюда, усложняя систему и создавая ненужные зависимости.

## 2. Creator (Создатель)

### Задача:
Этот шаблон определяет, какой объект должен создавать экземпляры других объектов. Обычно это тот объект, который использует создаваемые объекты или содержит их.

### Пример:
`Order` создает свои `OrderItem`, потому что он владеет этими объектами и управляет их жизненным циклом.

```python
class OrderItem:
    def __init__(self, product, quantity):
        self.product = product
        self.quantity = quantity

class Order:
    def __init__(self):
        self.items = []

    # Creator: Order создаёт OrderItem, потому что он управляет списком товаров.
    def add_item(self, product, quantity):
        self.items.append(OrderItem(product, quantity))

# Пример использования
order = Order()
order.add_item("Laptop", 1)
order.add_item("Mouse", 2)
```

### Как было бы неправильно:
Если бы создание `OrderItem` было вынесено в другой объект, например, в контроллер или другой слой системы, это нарушило бы связанность, так как `Order` является владельцем этих объектов.

## 3. Controller (Контроллер)

### Задача:
Этот шаблон определяет объект, который управляет обработкой событий или координирует выполнение задач.

### Пример:
В веб-приложении, контроллер обрабатывает запросы пользователей, создаёт заказы и взаимодействует с бизнес-логикой.

```python
class OrderController:
    def create_order(self, item_data):
        order = Order()
        for product, quantity in item_data:
            # Controller координирует создание заказа и взаимодействие с бизнес-логикой
            order.add_item(product, quantity)
        return order

# Пример использования
controller = OrderController()
order = controller.create_order([("Laptop", 1), ("Mouse", 2)])
```

### Как было бы неправильно:
Если бы заказы создавались непосредственно в интерфейсе или во внешнем слое системы, бизнес-логика была бы разбросана, что сделало бы код менее управляемым.

## 4. Low Coupling (Низкая связность)

### Задача:
Этот шаблон стремится минимизировать зависимость между объектами, чтобы изменения в одном объекте минимально влияли на другие.

### Пример:
Мы используем абстракции для взаимодействия с базой данных, чтобы минимизировать зависимость бизнес-логики от конкретных реализаций.

```python
class OrderRepository:
    def save(self, order):
        # Low Coupling: OrderRepository отвечает за сохранение, а Order за бизнес-логику
        print("Сохраняем заказ в базу данных")

class OrderService:
    def __init__(self, repository):
        self.repository = repository

    def process_order(self, order):
        # Здесь бизнес-логика не зависит от конкретной реализации базы данных
        self.repository.save(order)
```

### Как было бы неправильно:
Если бы бизнес-логика напрямую взаимодействовала с базой данных без абстракции, любые изменения в базе данных потребовали бы изменения бизнес-логики.

## 5. High Cohesion (Высокая связанность)

### Задача:
Этот шаблон увеличивает концентрацию ответственности в одном классе, делая код более понятным и лёгким в поддержке.

### Пример:
Мы разделяем ответственность за отправку уведомлений в отдельный класс.

```python
class NotificationService:
    # High Cohesion: Уведомления обрабатываются здесь, а не в бизнес-логике
    def send_order_confirmation(self, order):
        print(f"Отправляем подтверждение для заказа с товарами: {order.items}")

class OrderService:
    def __init__(self, notification_service):
        self.notification_service = notification_service

    def complete_order(self, order):
        self.notification_service.send_order_confirmation(order)
```

### Как было бы неправильно:
Если бы класс `OrderService` также отправлял уведомления, это бы увеличило его ответственность, усложнив поддержание кода.

## 6. Polymorphism (Полиморфизм)

### Задача:
Этот шаблон позволяет объектам разного типа обрабатывать команды через одинаковый интерфейс.

### Пример:
Разные методы оплаты, такие как оплата картой и PayPal, реализуются через полиморфизм.

```python
class PaymentMethod:
    def process(self):
        raise NotImplementedError()

class CreditCardPayment(PaymentMethod):
    def process(self):
        print("Обработка оплаты картой")

class PayPalPayment(PaymentMethod):
    def process(self):
        print("Обработка оплаты через PayPal")

# Полиморфизм: Используем разные методы оплаты через общий интерфейс
def process_payment(payment_method: PaymentMethod):
    payment_method.process()

# Пример использования
process_payment(CreditCardPayment())  # Обработка оплаты картой
process_payment(PayPalPayment())      # Обработка оплаты через PayPal
```

## Заключение

GRASP помогает правильно распределять ответственность между объектами системы. Вот краткое резюме того, какие задачи решают эти шаблоны:
- **Information Expert**: Определяет, кто должен выполнять задачу.
- **Creator**: Определяет, кто создаёт объекты.
- **Controller**: Управляет и координирует задачи.
- **Low Coupling**: Минимизирует зависимость между объектами.
- **High Cohesion**: Концентрирует ответственность в классе.
- **Polymorphism**: Позволяет обрабатывать команды через общий интерфейс.


----

## 2. YAGNI (You Ain't Gonna Need It)

**YAGNI** — это принцип программирования, который гласит: "Тебе это не понадобится". Он призывает не добавлять функциональность в код, если она не требуется на данный момент.

### Основные задачи YAGNI:
- **Избегание избыточной сложности**: Не стоит добавлять функционал, который может никогда не понадобиться.
- **Упрощение разработки**: Чем меньше кода, тем легче его поддерживать.
- **Экономия времени**: Вы не тратите время на написание ненужного кода.

### Пример применения YAGNI:

Вы разрабатываете систему управления пользователями. На этапе проектирования может возникнуть мысль добавить поддержку нескольких языков интерфейса, но на данный момент у системы только один язык. Принцип YAGNI подскажет, что не нужно реализовывать поддержку нескольких языков, пока не появится реальная необходимость.

```python
class User:
    def __init__(self, username):
        self.username = username
```

Вместо этого вы добавите многоязычность, когда этого потребует бизнес или появится реальный запрос.

----
## SOLID
**SOLID** — это набор из 5 принципов, направленных на улучшение дизайна объектно-ориентированных систем:

1. **S — Single Responsibility Principle (Принцип единственной ответственности)**: Класс должен иметь только одну причину для изменения.
2. **O — Open/Closed Principle (Принцип открытости/закрытости)**: Классы должны быть открыты для расширения, но закрыты для модификации.
3. **L — Liskov Substitution Principle (Принцип подстановки Барбары Лисков)**: Подклассы должны быть заменяемыми на свои базовые классы без нарушения логики программы.
4. **I — Interface Segregation Principle (Принцип разделения интерфейсов)**: Клиенты не должны зависеть от интерфейсов, которые они не используют.
5. **D — Dependency Inversion Principle (Принцип инверсии зависимостей)**: Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций.

### Пример использования SOLID:
Представим класс `Employee` с методом для сохранения информации о сотруднике в базу данных. Нарушение SRP произойдет, если в этом же классе будет логика сохранения информации. Чтобы следовать SRP, нам нужно вынести логику работы с базой данных в отдельный класс `EmployeeRepository`.

## Отличия между GRASP, YAGNI и SOLID:
- **GRASP** больше фокусируется на проектировании и распределении ответственности между объектами.
- **YAGNI** — это принцип практической разработки, призванный избежать ненужных функций и кода.
- **SOLID** фокусируется на написании хорошо структурированного и поддерживаемого кода с минимальными зависимостями.

### Заключение:
- **GRASP** помогает распределить ответственность в коде.
- **YAGNI** подсказывает не добавлять лишнего.
- **SOLID** структурирует код, делая его легко поддерживаемым и расширяемым.
