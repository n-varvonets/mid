
# Пример паттерна Наблюдатель с использованием asyncio

В данном примере показано, как паттерн **Наблюдатель** может быть реализован с помощью `asyncio` и `await`. 


- `карутина простыми словами `- это асинк функция, которая вызывается через луп.... Корутина — это специальная функция, которая может быть приостановлена и возобновлена в любой момент. Она используется для написания асинхронного кода, который не блокирует основной поток выполнения программы. Корутины в Python создаются с помощью ключевого слова `async`, а для приостановки их выполнения используется `await`.


- `loop` -  Событийный цикл управляет выполнением корутин и задач: он приостанавливает одну корутину, когда она ждёт чего-то (например, данных или завершения другой задачи), и запускает другую задачу в это время. 


## Пример:
`Коррутины` выступают `в роли подписчиков`, которые ожидают выполнения задач (событий) от `издателя`. 


```python
import asyncio

# Издатель, выполняющий задачи и уведомляющий подписчиков
# Функция является корутиной благодаря ключевому слову `async`
async def publisher(loop):
    for i in range(5):
        # Симулируем выполнение какой-то задачи
        print(f"Издатель: выполняю задачу {i}...")
        # await используется для того, чтобы приостановить выполнение корутины на 1 секунду.
        # В это время другие задачи могут выполняться.
        await asyncio.sleep(1)  # имитация долгой работы

        # Когда задача завершена, уведомляем подписчиков 
        print(f"Издатель: уведомляю подписчиков о задаче {i}")
        
        # Прокидываем результат в наблюдателя через event loop.
        # `call_soon` ставит задачу (observer) в очередь на выполнение в loop.
        # Прокидываем результат (номер задачи `i`) в observer.
        loop.call_soon(observer_1, i)  # уведомляем первого наблюдателя
        loop.call_soon(observer_2, i)  # уведомляем второго наблюдателя
        loop.call_soon(observer_3, i)  # уведомляем третьего наблюдателя
        loop.call_soon(observer_4, i)  # уведомляем четвертого наблюдателя

# Подписчики (наблюдатели), которые реагируют на уведомления
# Эти функции не являются корутинами, они вызываются синхронно через loop

def observer_1(task_number):
    print(f"Подписчик 1: получил уведомление о задаче {task_number}")

def observer_2(task_number):
    print(f"Подписчик 2: получил уведомление о задаче {task_number}")

def observer_3(task_number):
    print(f"Подписчик 3: получил уведомление о задаче {task_number}")

def observer_4(task_number):
    print(f"Подписчик 4: получил уведомление о задаче {task_number}")

# Основная корутина, которая управляет циклом событий (loop) и запускает издателя
async def main():
    # Получаем текущий событийный цикл (event loop)
    loop = asyncio.get_event_loop()

    # Запускаем корутину publisher, которая выполняет задачи и уведомляет подписчиков
    await publisher(loop)

# asyncio.run — это точка входа для запуска корутины
# Оно запускает корутину main() и управляет событийнным циклом
asyncio.run(main())
```

## Объяснение:

### Издатель (publisher):

Функция `publisher()` является издателем. Она выполняет цикл на 5 итераций, где каждая итерация представляет собой выполнение задачи. По завершении каждой задачи издатель уведомляет подписчиков через вызовы `loop.call_soon`, передавая им номер завершенной задачи.

### Подписчики (наблюдатели):

Подписчиками выступают функции `observer_1`, `observer_2`, `observer_3` и `observer_4`. Они вызываются синхронно через событийный цикл (`loop.call_soon`) и реагируют на уведомления, выводя номер завершенной задачи.

### Основные моменты:

- **await asyncio.sleep(1)**: Приостанавливает выполнение корутины на 1 секунду, чтобы показать асинхронное выполнение.
- **loop.call_soon**: Добавляет задачи (подписчиков) в очередь событийного цикла для немедленного выполнения.
- Подписчики работают синхронно, так как они вызываются через событийный цикл, но не являются корутинами.
