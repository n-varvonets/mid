
# Пример паттерна Наблюдатель с использованием asyncio и задач

В данном примере показано, как паттерн **Наблюдатель** может быть реализован с помощью `asyncio`, `await` и задач, которые добавляются в событийный цикл.

- **Корутина** — это функция, которая может быть приостановлена и возобновлена. Она используется для асинхронного выполнения, не блокируя основной поток программы. В Python корутины создаются с помощью ключевого слова `async`, и их выполнение может быть приостановлено с помощью `await`.
  
- **loop** — событийный цикл, который управляет выполнением задач и корутин. Когда корутина приостанавливается (например, ожидая завершения задачи), цикл может переключаться на выполнение других задач.

## Пример:
В данном примере корутины выступают как подписчики, которые ожидают уведомления от издателя о выполнении задач. Издатель генерирует задачи и уведомляет подписчиков через событийный цикл.

```python
import asyncio

# Издатель, выполняющий задачи и уведомляющий подписчиков
async def publisher(loop):
    for i in range(5):
        # Симулируем выполнение какой-то задачи
        print(f"Издатель: выполняю задачу {i}...")

        # await приостанавливает выполнение корутины на 1 секунду
        await asyncio.sleep(1)  # имитация долгой работы

        # Когда задача завершена, уведомляем подписчиков через loop
        print(f"Издатель: уведомляю подписчиков о задаче {i}")

        # Создаем задачи, используя call_soon
        # Каждый наблюдатель будет уведомлен о завершенной задаче
        loop.call_soon(observer_1, i)
        loop.call_soon(observer_2, i)

# Подписчики (наблюдатели), которые реагируют на уведомления
def observer_1(task_number):
    print(f"Подписчик 1: получил уведомление о задаче {task_number}")

def observer_2(task_number):
    print(f"Подписчик 2: получил уведомление о задаче {task_number}")

# Задача, которая будет выполняться как отдельная корутина
async def async_task(task_number):
    print(f"Задача {task_number} начинает выполнение...")
    await asyncio.sleep(2)  # имитируем длительную задачу
    print(f"Задача {task_number} завершена!")

# Основная корутина
async def main():
    # Получаем текущий событийный цикл
    loop = asyncio.get_event_loop()

    # Запускаем корутину publisher, которая уведомляет подписчиков
    await publisher(loop)

    # Создаем асинхронные задачи, которые управляются событийным циклом
    tasks = []
    for i in range(3):
        # Создаем и запускаем задачи через asyncio.create_task
        task = asyncio.create_task(async_task(i))
        tasks.append(task)

    # Ожидаем завершения всех задач
    await asyncio.gather(*tasks)

# Запуск корутины через asyncio.run
asyncio.run(main())
```

## Объяснение:

### Издатель (publisher):

`publisher()` — это корутина, которая в цикле выполняет задачи. По завершении каждой задачи издатель уведомляет подписчиков через вызов `loop.call_soon()`, передавая номер завершенной задачи. 

### Подписчики (наблюдатели):

`observer_1` и `observer_2` — это функции, которые получают уведомления от издателя. Эти функции выполняются синхронно через событийный цикл, но они не блокируют выполнение других задач, так как запускаются через `loop.call_soon()`.

### Асинхронные задачи:

Добавлен пример создания и управления задачами с помощью `asyncio.create_task`. Эти задачи представляют собой корутины (`async_task()`), которые выполняют длительные действия асинхронно.

- **async_task()** — это корутина, которая имитирует выполнение длительной задачи с помощью `await asyncio.sleep(2)`.

### Основные моменты:

- **await asyncio.sleep(1)** приостанавливает выполнение корутины для демонстрации асинхронного выполнения.
- **loop.call_soon** добавляет функции наблюдателей в очередь для немедленного выполнения, как только текущая корутина завершится.
- **asyncio.create_task** используется для запуска асинхронных задач, которые работают параллельно с основным потоком выполнения.
- **asyncio.gather** ожидает завершения всех асинхронных задач.

Этот пример демонстрирует, как можно управлять задачами и уведомлениями с использованием паттерна "Наблюдатель" и асинхронных функций в Python.
