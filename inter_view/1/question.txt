1. по какой причине нью может не первым?


2. идемпотентность это методов


3. что в jwt токенах и хранятся ли они в бд. джанго?


4. как в список поместить множество других списков в список. через вор и екстенд? а как можно улучшить?

5. по какой причине не заходит в post_save джанго?
- Сигнал post_save срабатывает, если вы используете get_object() и затем сохраняете объект через вызов .save().
- Сигнал не срабатывает, если вы используете метод update() через QuerySet, например, через MyModel.objects.filter(pk=1).update(), так как этот метод напрямую обновляет данные в базе данных.


6.0.Гененатор и итератор
Генератор - функция, которая имеет ключеваое слово yeild, возращая елменті по однмоу с коллекции
Итератор - обьект, которій может проходится по коллекции и имет дандер методі __iter__, __next__

6.1.в чем разница между тапла и сета? Раскажи глубже про сет
6.2. Хеш-таблица:
это структура данных, которая использует хеш-функцию для вычисления индекса (хеш-значения) ключа и вставляет его
в соответствующую ячейку в массиве. Это позволяет быстро находить элемент по ключу.


7.как реализуются контекстный менеджер. можно ли реализовать декоратор через клас? и в чем разница тогда класово декратора
от класового котестного менеджера? что-то похожу на трай ексепт финали?
**Контекстный менеджер** должен реализовать два метода:
- `__enter__()` — выполняется при входе в блок `with`.
- `__exit__()` — выполняется при выходе из блока `with`, и здесь можно обрабатывать исключения.
**Классовый декоратор** оборачивает функцию и контролирует её выполнение с помощью метода `__call__()`
Использование классового декоратора для обработки исключений не всегда подходит по причине:
- Декораторы оборачивают всю функцию и обрабатывают исключения на уровне вызова функции, а не конкретного фрагмента кода.


8. на класс можно навешать декратор? пример с джанго
- Декоратор на классе in python позволяет изменить или дополнить его поведение. Например, можно добавить логику до или после создания экземпляра класса.(например метода __init__)
- При использовании декораторов с классами представлений в Django, нужно учитывать, что каждый метод обрабатывает разные типы запросов (GET, POST и т.д.),
поэтому правильным способом будет применение декоратора к методу `dispatch`, который отвечает за маршрутизацию запросов.


9.1. чем отличается балк апдейт от обычного апдейта? как ефективно обновить 2 млн записей в таблице,
что в каждом поле изменить уникальнкю информацию(значение) которая расчитывается отедьлно для кажой записи.
update - Подходит только для случаев, когда нужно обновить все записи одним и тем же значением. (Не вызывает сигналы)
bulk_update — это метод, позволяющий обновить сразу несколько объектов в базе данных с разными значениями полей за один SQL-запрос. (Не вызывает сигналы)

9.2.В джанго есть values()  и  only() в чем их разница?
values() возвращает данные в виде словарей {}.. т.е. ['']
only() загружает указанные поля, возвращает объекты модели,(ОБРАЩАТЬСЯ ЧЕРЕЗ ТОЧКУ) сохраняя возможность работать с их методами и взаимодействовать с базой данных при необходимости.


10. что такое кодировка?
таблица соответсвий символ в байты/машынный код, поэтому ютф-8 такая популярная.
Поэтому в текстовом файле неважно гле мсиволы ноходяться,  потому что они(символы) будут соответсвовать одному и тому же байтам.
В отличии от исполняемого файла, где структура это важно


11. почему после десерилизации удобнее работать с обьектом, а не словарем, ведь приходит к нам джсон.. т.е. почему к обьекту мы обращаемся через точку, а не ['']?
на дает десериализацию пришедшего json(байты, то что мы в текст переводим, мы доставем кодировку и кодируем эти символы.. просто текст)
и десириализация нужна для валидации данных, т.е. соответсвия контракта( соотвуетсвующий инпут от клиента). и вот валиадцаия этих полей
лучше делать при помощи обьектов пайтона, инкапслуруя в них логику валдиации через ооп (пайдентик бибилотека из под капота джанго)


12. как работает конкуретность в пайтоне,какие виды(вытесняющая и т.п.)
1.Вытесняющая многозадачность в реальности: (На одноядерных системах невозможна реальная параллельная работа программ? только имитация)
- **Контекст переключения**: Когда операционная система решает, что пришло время переключить задачи, она сохраняет текущее состояние (регистры, стек, адрес памяти) первой программы и загружает состояние второй.
- **Тайм-слоты**: Каждой программе выделяется крошечный тайм-слот (например, 10-100 миллисекунд). Этого достаточно, чтобы интерфейсы программ оставались отзывчивыми.
2.а. Конкурентность - подразумевает, что мы запустили задачу, НО не дожидаемся ее ответа и переходим к следующей (НЕ ОДНОВРЕМЕННО).Например,
- Гроссмейстер и игра с несколькими соперниками, где Ход гроссмейстера — это выполнение части задачи (например, загрузка данных, обработка файлов и т.д.).
Зависит от ПО, как мы написали наш код.
2.б. Паралельность- єто 10 грасомейсторов на 100 игркоков и очведно что 10ть партий идет физически в один и тот же момент(ОДНОВРЕМЕННО)
сколько ядер у нас есть, то ЄТО МАКСИМАЛЬНОЕ количество параллелльности и ЗАВИСИТ ОТ ЖЕЛЕЗА.
3.а. ПРОБЛЕМА - ПОТОКОБЕЗОПАСНОСТЬ
- взаимоблокировка - два потока ждут выполнение друг друга и ни один из них не может продолжить выполнение. РЕШЕНИЕ?
--- Порядок блокировок: (t1.start() --> t1.join() -->  t2.start() --> t2.join())
--- Тайм-ауты:  чтобы поток не зависал в ожидании слишком долго.
--- Блокировки с проверкой: Использовать функции вроде try_lock,
- состояние гонки - когда несколько потоков одновременно пытаются изменить общий ресурс. РЕШЕНИЕ?
--- Использование блокировок (Locks): Обеспечить, что только один поток может изменять данные в любой момент времени.
--- Семафоры и другие синхронизационные примитивы: Управление доступом к общим ресурсам.
----- Семафор имеет счетчик доступных разрешений.
----- Semaphore(3): Разрешает одновременно 3 потока.
----- acquire(): Поток захватывает ресурс, уменьшая счётчик.
----- release(): Поток освобождает ресурс, увеличивая счётчик.
----- Потоки, которым не хватает разрешений, ждут, пока ресурс освободится.
4. io vs cpu bound. GIL.
GIL не блокирует выполнение I/O операций(запросы в веб (WEB), работа с файлами (File) или базами данных (DB)) - их выполняет ОС вне языка програмирования,
потому что они выполняются ВНЕ Python-интерпретатор, а значит ВНЕ ЕГО GIL... только блокирует  CPU задачи(их уже выполняет внутри питона)
- т.е. не сам ПИТОН читает файл, он дает задание ОС и верни мне ответ... и у пайтона там нет власти
4.a. NumPy and Pandas работают точно также - у них основная логика написана на С и она лежит отдельно от пайтона-GIL
5. различия threading и asyncio в том что в asyncio запускает один поток(бістрая конкуретность-шахматы), а в трединке несколько блокирующих потоков
- **Гроссмейстер** — это процессор, который выполняет задачи (или "ходы").
- **Игроки** — это задачи (или потоки), которые ожидают очередного хода от процессора.
- **Ход гроссмейстера** — это выполнение процессором одной части задачи в рамках одного потока.


13. почему пайтон медленный
- Интерпретируемый язык
- Глобальная блокировка интерпретатора (GIL)
- Динамическая типизация
- Высокоуровневые абстракции


14. как построить архитектуру под эти патерны? (Архитектура и использование паттернов проектирования)
- Паттерны проектирования были не "придуманы", а "открыты
- Это не оригинальные решения, а типовые подходы, которые повторяются при решении одинаковых проблем. Термин "GoF book"
- Надо не искать возможность куда паттерны впихнуть.. потому что патерн решает конкретную проблему, если этой проблемы нет, то ее решать не нада
    - Нужно ли создавать объекты динамически? — Открываем порождающие паттерны.
    - Нужно ли менять поведение в зависимости от ситуации? — Рассматриваем поведенческие паттерны.
    - Нужно ли структурировать или связывать разрозненные компоненты? — Обращаемся к структурным паттернам.

14.2 Observer Pattern
- Паттерн Наблюдатель используется для создания системы подписки, которая позволяет объектам получать уведомления об изменениях в других объектах.
- субъект хранит список своих наблюдателей и уведомляет их об изменениях своего состояния. Наблюдатели подписываются на субъект,
чтобы автоматически получать обновления.
14.3.Singlton - антипаттерн
- нарушает принцип Single Responsibility из-за глобального состояние в приложении
14.4.Chain of Responsibility - паттерн цепочка обьязаностей и генератор send().
(Телеграм учтоняющие вопросы по одному собирает инфу о клиенте - т.е. на каждой интерации с тобой задает тебе вопросы)
- цеопчка задавания вопросов - явный патерн цепочка обьязаностей

15. почему нельзя прокидывамуть мутабильные обьекты в функцию?
- потому что тогда аргумент будет хранить указатель на обьект и при последующих вызовов функции в других местах аргумент НЕ БУДЕТ ЗАНОВО ИНЦИАЛИЗИРОВАН
- можно через Ноне прокнуть какой динамический аргумент + тайпхинтинг


16. генераторы и сопрограмы
- генераторы - функция с yeild. при каждом новом вызове функции next() код генератора исполняется с места где в прошлый раз вернул значение.
-- в этом и отличие от return(который убивает весь стек вызова функции, а yield делает так что стек сохраняется)
-- в генераторе может быть return что б завершить стек вызов
- сопрограми
-- корутины, они асинхронные функцие, КОТОРЫЕ ПОСТРОЕНЫ на генераторах
-- т.е. генератор который принимает данные через send() называется корутины генераторов, НО НЕ асинхронной функцией


17.threading


18.утиная типизация
- Если это выглядит как утка, плавает как утка и крякает как утка, то это утка
- В Python нет необходимости явно указывать, что два класса должны следовать какому-то интерфейсу.
-- Если объект имеет такой метод, он может быть передан в функцию. Если объект не имеет нужного метода, программа выдаст ошибку только во время выполнения, а не на этапе компиляции.
-- просто. если обьект реализует метод(интерфейс), то он считается данным типом (уткой)
если объект поддерживает нужные методы и свойства, его можно использовать, независимо от его реального типа или класса.

19. в чем разница между тайп и object в метаклассах?
- type — (создаль классов) создает классы, потому что класс ЯВЛЯЕТСЯ ЕКЗЕМЛЯРОМ(инстансоv) класса type
- object — (родитель классов) класс от которого любой созданный класс наследует какие-то аттрибуты
```
class MyClass:
    pass
my_instance = MyClass()
print(isinstance(my_instance, object))  # Выведет: True
print(isinstance(my_instance, type))  # Выведет: False
print(type(MyClass))  # Выведет: <class 'type'>  -  В Python классы создаются с помощью метакласса type. Это означает, что сам класс MyClass является экземпляром метакласса type
print(type(type))  # Выведет: <class 'type'>
```
схема:
    object
      └── type
          ├── MyClass
          │   └── my_instance
          └── type


20. GIL. Что такое состояние гонки?
— был введен, что б защищать внутренние структуры данных И ИЗБЕЖАТЬ СОСТОЯНИЕ ГОНКИ
--- несколько потоков или процессов одновременно пытаются изменить одни и те же данные,
--- и порядок выполнения этих потоков или процессов не определён.


21. Что делали если б не было веб-фрейморвков?
Пришлось бы разрабатывать
- Обработка HTTP-запросов:
- Маршрутизация (Routing):
- Поддержка сессий и авторизации:
- Безопасность: (от XSS, CSRF, SQL-инъекций и других атак самостоятельн)
- Обработка баз данных


22. что такое чистая архитектура?
проблема разрабов долгосрочніх проектах, єто
- рост кодовой базы
- контроль над этим всем
Чистая архитектура в долгосроке дает УДОБНОЕ СОПРОВОЖДЕНИЕ проекта. - разделяет приложение на независимые слои.
Основная идея — бизнес-логика приложения не должна зависеть от внешних систем (баз данных, фреймворков, UI).
Пример: луковая архитектура - архитектура из слоёв:
- ядро: бизесс логика
- 1ый слой: сервисы aws и т.д.
- 2ой слой бд,броекры, внешние API
- поседний слой - вебфреймоврки(http, routing, security)


23. про связность(Cohesion) и связанность(Coupling)
Идеальный баланс:
Высокая связность (внутри модуля) + низкая связанность (между модулями) — это идеал в проектировании.
Это означает, что каждый модуль делает одну задачу хорошо (связность), и изменение одного модуля минимально влияет на другие (связанность).


24. микросервисы, монолит, распределнный монолит и принцип душения
Микросервисы — это когда приложение делится на небольшие, независимые сервисы,
каждый из которых отвечает за одну конкретную задачу или бизнес-функцию.
Преимущества микросервисов:
    - Масштабируемость: Можно масштабировать только те сервисы, которые требуют дополнительных ресурсов, не затрагивая другие части системы.
    - Независимая разработка: Команды могут работать над разными микросервисами независимо друг от друга, что ускоряет разработку.
    - Устойчивость к сбоям: Если один микросервис выходит из строя, это не обязательно влияет на работу всей системы.
    - Гибкость в технологиях: Для каждого микросервиса можно выбрать наиболее подходящую технологию и язык программирования.
    - БД: используют разные БД, а взаимодействуют по ЕНДПОНИТАМ
    - git: каждый сервис хранится отдельно по репозиториям
Недостатки микросервисов:
    - Сложность управления: Большое количество микросервисов может усложнить управление системой, мониторинг и отладку.
    - Межсервисная коммуникация: Требуется дополнительная инфраструктура для обеспечения надежного взаимодействия между сервисами.

Ну монолит мы тоже масштабировать.. просто запустить две реплики монолита, которую смотрт в одну базу, НО в этом то и проблема

Если один сервис требует компоненты, который обрабатывает другой, то нужно по ЕНДПОИНТАМ постучаться другого(НО НЕ ОБРАЩАТЬСЯ к одной и той же БД),
потому что когда один микросервис лезит в БД другого микросервиса, то ЭТО В ДОЛГОСРОКЕ ПЛОХО.. как раз про связаность.

Заключение
    - Микросервисы лучше подходят для сложных и масштабируемых систем, где требуется гибкость и независимость компонентов.
    - Распределённый монолит сохраняет зависимость компонентов и данных, что ограничивает масштабируемость.
    - Принцип душения помогает постепенно перейти от монолита к микросервисам, минимизируя риски.


25. Как взаимодействуют микросервисы? определнный интерфейс. почему лучше использовать (Message Queues)
и консьюмеров вместо http запросов и что такое  API Gateway?

26.а) Какие проблемы решает брокер?
Например, Есть веб сервис, который принима
ет задания ОТ КЛИЕНТА, єтот сервис пушит задания в брокер консьмера, а другой сервис читает задание консьюмера и выполняет его.
Таким образом нужно
- принять сообщение
- преоброзовать егов таску
- сериализовать в байты
- отправить в брокер у нужному консьюмеру
Решает задачи:
- Брокер позволяет положить таску в очередь и по мере постпления их обробатывать, тем самым решая проблему загруженности.
--Т.Е. АСИНХРОННО решает проблемы, в отличии от http запросов,которій решает задачи СИНХРОННО
- так жен 2ой сервис(который выполняет задачу)  - упадет(таймаут и т.д.), то сообщение/таска пользователя НЕ ПОТЕРЯЕТСЯ
- это dependancy inversion для архитектуры -  микросервеси ненапрямую взаимдействуют друг с другом, а через некую абстракцию(брокера), при том что сервисы не подозревают о существовании друг друга
26.б) Какие проблемы он приносит?
- это отдельный сервис и нужен под него сервер, нужно его поддерживать


27. кафка это и брокер и консьюмер?  каким образом консьюмер понимает что надо забрать сообщение
- Консьюмеры — это не программные продукты, а конкретные микросервисы или программы, которые ты разрабатываешь, чтобы забирать сообщения из брокеров.
- Консьюмеры подписываются на очередь в брокере сообщений. После подписки:
    - Брокер сообщений (например, RabbitMQ или Kafka) кладёт сообщение в очередь.
    - Консьюмер постоянно проверяет очередь или получает сообщение, как только оно появляется.
    - Консьюмер забирает сообщение и выполняет задачу (например, обрабатывает заказ или отправляет уведомление).


28. в чем разница между виртуальной машиной и контейнером?где запустить наше приложение в виртальной машине в облаке или в контейнере в облаке?
- Контейнер - изолция на уровне ОС. ядро ОС(линкус напрмер - Общая ОС с хостом) предоставляет МЕХАНИЗМІ ИЗОЛЦИИ ПРОЦЕССОВ(application layer) от других проессов - легкая
- Виртуализцаия - Каждая VM имеет свою ОС, т.е. полная изоляция, независимая ОС - медленная. Т.е. ОС запущенная в VM думает,
что она имеет прямой доступ к железу, а на самом деле НЕТ. Между неими прослойка, которая создает ГИПЕРВИЗОР в хотчевой ОС
Проблема: - у докера есть демон
- Клиент и сервер: Docker работает по принципу "клиент-сервер". Клиент (команда Docker) отправляет запросы демону,
который обрабатывает их.(Т.Е. отправляет запрос ядро, типо "ей ядро, запусти мне процесс такой-то или оставнови")
- Фоновая работа: демон работает постоянно, ожидая команд (например, запуск или остановка контейнера).
- Если демон Docker отключается или выходит из строя, управление контейнерами прекращается, и все контейнеры могут остановиться. - ЕГО НУЖНО ПОДДЕРЖИВАТЬ И СЛЕДИТЬ ЗА НИМ


29. в чем разница между докером и докер компоуз?
- Docker: Управляет отдельными контейнерами (например, запуск одного веб-сервера).
- Docker Compose: Позволяет запускать несколько связанных контейнеров одновременно (например, веб-сервер, база данных и кэш вместе).

30. что такое ACID в бд..
- A	Atomicity	Атомарность: транзакция либо завершается полностью, либо не происходит ничего.
- C	Consistency	Согласованность: данные в базе данных всегда находятся в согласованном состоянии после транзакции.
Для достижения согласованности применяются триггеры, ограничения и бизнес-логика (например, проверка на минимальный баланс)
- I	Isolation	Изолированность: параллельные транзакции не влияют друг на друга.
- D	Durability	Надёжность: после завершения транзакции её результаты сохраняются даже в случае сбоя системы.
30.а.  Если в двух вкладках нажали "Оплатить" одновременно — произойдёт ли двойная оплата?
- Одним из самых эффективных решений является введение идемпотентности транзакций
    - Каждой транзакции присваивается уникальный идентификатор (например, номер заказа, номер транзакции).
    - Когда пользователь отправляет запрос на оплату, система сохраняет этот идентификатор и проверяет его перед выполнением транзакции.
    - Если другой запрос с тем же идентификатором приходит снова (даже если его отправили через другую вкладку или с задержкой),
      система понимает, что это повторный запрос, и просто игнорирует его, так как транзакция уже была выполнена.
- Использование блокировок на уровне базы данных (Isolation и Locking)
    - Когда первый запрос на оплату приходит, система блокирует запись в базе данных, которая относится к счёту клиента.
    - Пока транзакция первого запроса не завершится (успешно или с ошибкой), второй запрос не сможет изменить те же данные.
    - После завершения первой транзакции блокировка снимается, и следующий запрос может быть обработан.   -
Пример реализации: КОМБИНАЦИЯ методов и система будет работать:
    - Запросы отправляются одновременно, все с идентификатором транзакции TX12345.
    - Первый запрос проходит через проверку и блокирует запись о балансе пользователя.
    - Пока первый запрос обрабатывается, все другие запросы с тем же идентификатором либо блокируются, либо отклоняются как повторные.
    - После завершения первой транзакции другие запросы проверяются, но видят, что идентификатор транзакции TX12345 уже обработан, и не выполняются.
30.б. Серилизация транзакций — это один из методов блокировки, при котором транзакции выполняются последовательно,
как бы "по очереди". Это гарантирует, что каждая транзакция выполняется в изолированном состоянии,
и данные не изменяются до завершения текущей транзакции. (в отличии от ГРЯЗНОГО ЧТЕНИЯ, что не начинать работать с незавершенной транзакцией)


31. NoSQL, JSON и BASE
- В реляционных базах данных (SQL) данные хранятся в таблицах с фиксированной схемой.
В NoSQL данных нет строгой схемы, и вместо таблиц используются коллекции или индексы, где каждый документ может иметь разную структуру.
- Поэтому Простота работы с JSON: NoSQL базы предоставляют более удобные механизмы для работы с JSON,
такие как встроенные инструменты для поиска и обновления JSON-документов.
- в BASE, S - Soft state	Состояние системы может изменяться со временем, даже без запросов,
где ВА - Данные всегда доступны, но могут быть временно несогласованными.(не иметь конкретизации аттрибутов документов или как?)


32. что такое пирамида тестирования. почему єто пирамида, а не треугольник?
Пример правильного баланса:
- Модульные тесты: 100 тестов. (отдельные функции без зависимости от внешних систем или Мок тестирование(изолировать тестируемую функцию от внешних зависимостей))
- Интеграционные тесты: 20 тестов. (взаимодействие с бд и внешними апи)
- End-to-End тесты: 10 тестов. (прохождение юезр кейсов)


33.в чем разница между агригацией и композицией?
Агрегация и композиция — это два типа ассоциаций между объектами в ООП. Оба типа описывают отношение "часть-целое" между объектами,
| Характеристика       | Агрегация                           | Композиция                        |
|----------------------|-------------------------------------|-----------------------------------|
| Сила связи           | Слабая (части могут существовать отдельно) | Сильная (части не могут существовать без целого) |
| Взаимозависимость     | Части могут существовать независимо | Части зависят от существования целого |
| Жизненный цикл       | Части могут пережить целое          | Части уничтожаются вместе с целым |
| Пример               | Студенты и университет              | Двигатель и автомобиль            |
--------------------------------------------------------------------------------------------------
В Django отношения агрегации и композиции между моделями могут быть выражены через различные типы связей,
такие как OneToMany (один ко многим) с разными стратегиями удаления.


34. GRASP, YAGNI и SOLID: В чем разница?


36.async, корутина, луп
Корутина — это функция, которая может быть приостановлена и возобновлена. Она используется для асинхронного выполнения,
не блокируя основной поток программы. В Python корутины создаются с помощью ключевого слова async, и их выполнение может
быть приостановлено с помощью await.
loop — событийный цикл, который управляет выполнением задач и корутин.


37. GROUP BY и HAVING

38. brokers

39. VPC_Subnets_Instances_Architecture.md


40. что происходит когда нажимаешь на кнопку поиска в гугл

41. http vs https, и почему именно S - єто защищенный, как шифрует?



