
# Проблема гонки данных в многопоточности и решение

## Причины вывода значения `1` вместо `100`:
1. **GIL (Global Interpreter Lock)**:
   - **GIL** ограничивает параллельное выполнение кода на уровне байт-кода Python, позволяя лишь одному потоку исполнять код Python в любой момент времени.
   - Однако **GIL не гарантирует атомарность операций!** В вашем случае операция `c = counter[0]` и последующее `counter[0] = c + 1` могут быть прерваны между чтением и записью, что вызывает **data race** (гонку данных).

2. **Конкурентное выполнение**:
   - Операции чтения и записи переменной `counter` не атомарны, они могут быть прерваны другим потоком.
   - В результате несколько потоков могут прочитать одно и то же значение и записать одно и то же значение обратно, теряя промежуточные инкременты.

## Почему GIL не "спас":
- **GIL** предотвращает выполнение более одного потока одновременно на уровне интерпретатора, но не защищает от проблем синхронизации при изменении общих данных.
- Операция `counter[0] = counter[0] + 1` не атомарна — она включает чтение и запись, которые могут быть прерваны.

## Сколько выполняется один поток до переключения?
Python переключает выполнение потоков через интервал, называемый **"ticks"**, который соответствует 5 миллионам байт-код инструкций по умолчанию. Это количество можно настроить с помощью `sys.setswitchinterval()`, где значение задаётся в секундах.

Пример: 
```python
import sys
print(sys.getswitchinterval())  # Вывод интервала переключения потоков
```
По умолчанию интервал переключения потоков — **0.005 секунд** (5 миллисекунд), но это значение может быть изменено через `sys.setswitchinterval(new_interval)`.

## Решение проблемы с использованием блокировки:

Чтобы избежать гонок данных и обеспечить корректное обновление переменной `counter`, следует использовать механизм синхронизации, такой как **lock**.

### Пример решения:

```python
import threading

counter = [0]
lock = threading.Lock()

def inc():
    with lock:
        c = counter[0]
        counter[0] = c + 1

if __name__ == '__main__':
    threads = [threading.Thread(target=inc, daemon=True) for _ in range(100)]

    for t in threads:
        t.start()

    for t in threads:
        t.join()

    print(counter[0])  # Ожидаемое значение теперь будет 100
```

### Объяснение:
- **`lock = threading.Lock()`** создаёт объект блокировки (lock).
- **`with lock:`** гарантирует, что только один поток сможет выполнить код внутри блока `with` в один момент времени.
- Это предотвращает гонки данных и гарантирует корректное инкрементирование переменной `counter`.

Теперь программа корректно выполнит инкрементацию переменной `counter`, и результат будет равен `100`.
