
# Объяснение GROUP BY и COUNT

### Почему нужен GROUP BY в данном случае?

Когда вы используете агрегатную функцию, такую как `COUNT`, в запросе вместе с другими столбцами, вам нужно указать, как именно сгруппировать строки, чтобы получить итоговое значение для `COUNT`. В данном случае, вы хотите получить количество продуктов для каждой конкретной компании. Вот как это работает:

- `GROUP BY company.id` группирует все строки, относящиеся к одной компании.
- `COUNT(product.id)` затем считает количество строк для каждой группы (в данном случае - количество продуктов для каждой компании).

**Без `GROUP BY`** SQL не будет знать, как сгруппировать строки, чтобы корректно применить агрегатную функцию `COUNT`. Это приведет к ошибке, потому что вы пытаетесь использовать `COUNT` и `company.id` вместе, не указав, как их объединить в единую группу.

### Пример со значениями

Рассмотрим пример со значениями для лучшего понимания:

**Таблица `product`**:

| id  | company_id |
| --- | ---------- |
| 1   | 2          |
| 2   | 1          |
| 3   | 1          |

**Таблица `company`**:

| id  |
| --- |
| 1   |
| 2   |

#### Пример после объединения с LEFT JOIN

Когда мы выполняем следующий запрос:

```sql
SELECT company.id, product.id AS product_id
FROM company
LEFT JOIN product ON company.id = product.company_id;
```

**Результирующая таблица после выполнения LEFT JOIN**:

| company.id | product.id |
| ---------- | ---------- |
| 1          | 2          |
| 1          | 3          |
| 2          | 1          |

Вот как это работает:

- **`LEFT JOIN`** присоединяет строки из таблицы `product` к таблице `company`, используя столбец `company_id`.
- Все компании включены в результирующую таблицу, а данные продуктов отображаются в зависимости от совпадений по `company_id`.

**Пояснение к таблице**:
- Компания с `id = 1` связана с продуктами с `id = 2` и `3`, поэтому в результирующей таблице появятся две строки для компании `1`.
- Компания с `id = 2` связана с продуктом с `id = 1`, поэтому для этой компании появляется одна строка.

Если мы выполним следующий запрос:

```sql
SELECT company.id, COUNT(product.id) AS product_count
FROM company
LEFT JOIN product ON company.id = product.company_id
GROUP BY company.id
ORDER BY product_count DESC;
```

**Результат будет следующим**:

| company.id | product_count |
| ---------- | ------------- |
| 1          | 2             |
| 2          | 1             |

- **`GROUP BY company.id`** группирует строки таблицы так, что для каждой компании считается количество продуктов.
- **`COUNT(product.id)`** возвращает количество продуктов для каждой компании.

### Разница между `GROUP BY` и `HAVING`

- **`GROUP BY`** используется для группировки строк по одному или нескольким столбцам. Он определяет, как именно агрегировать данные.
  
- **`HAVING`** используется для фильтрации групп, полученных после применения `GROUP BY`. Он похож на `WHERE`, но применяется на этапе, когда строки уже сгруппированы.

**Пример использования `HAVING`**:

```sql
SELECT company.id, COUNT(product.id) AS product_count
FROM company
LEFT JOIN product ON company.id = product.company_id
GROUP BY company.id
HAVING COUNT(product.id) > 1;
```

В этом случае `HAVING COUNT(product.id) > 1` отфильтрует группы, где количество продуктов больше 1.

**Результат**:

| company.id | product_count |
| ---------- | ------------- |
| 1          | 2             |

Таким образом, `HAVING` помогает фильтровать результат после группировки, тогда как `GROUP BY` выполняет саму группировку.

### Пример с реальной таблицей для GROUP BY

Рассмотрим более реальный пример. Допустим, у нас есть таблица `orders`, которая хранит информацию о заказах, выполненных различными клиентами:

**Таблица `orders`**:

| order_id | customer_id | amount |
| -------- | ----------- | ------ |
| 1        | 1           | 100    |
| 2        | 2           | 150    |
| 3        | 1           | 200    |
| 4        | 3           | 50     |
| 5        | 2           | 300    |

Цель: посчитать общую сумму заказов для каждого клиента.

**SQL-запрос**:

```sql
SELECT customer_id, SUM(amount) AS total_amount
FROM orders
GROUP BY customer_id;
```

**Результат**:

| customer_id | total_amount |
| ----------- | ------------ |
| 1           | 300          |
| 2           | 450          |
| 3           | 50           |

- **`GROUP BY customer_id`** группирует строки по `customer_id`, чтобы посчитать общую сумму для каждого клиента.
- **`SUM(amount)`** суммирует значения `amount` для каждого клиента, что позволяет узнать общую сумму заказов каждого из них.

Если мы хотим отобразить только тех клиентов, чья общая сумма заказов превышает 200, мы можем добавить `HAVING`:

**SQL-запрос с HAVING**:

```sql
SELECT customer_id, SUM(amount) AS total_amount
FROM orders
GROUP BY customer_id
HAVING SUM(amount) > 200;
```

**Результат**:

| customer_id | total_amount |
| ----------- | ------------ |
| 1           | 300          |
| 2           | 450          |

- **`HAVING SUM(amount) > 200`** фильтрует группы клиентов, у которых общая сумма заказов больше 200.

Таким образом, `GROUP BY` и `HAVING` часто используются вместе для агрегирования данных и дальнейшей фильтрации агрегированных результатов.
